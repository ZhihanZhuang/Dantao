<!DOCTYPE html>
<html lang="zh">
<head>
Â  <meta charset="UTF-8">
Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  <title>DANTAO (PC v2)</title>
Â  <style>
Â  Â  /* ğŸ¨ è§†è§‰è®¾è®¡ - è‰²å½©æ–¹æ¡ˆ */
Â  Â  body {
Â  Â  Â  margin: 0;
      padding: 0;
Â  Â  Â  background-color: #141428; /* æ·±è“é»‘èƒŒæ™¯ */
Â  Â  Â  overflow: hidden; /* é˜»æ­¢æ»šåŠ¨ */
Â  Â  Â  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
Â  Â  Â  user-select: none;
Â  Â  }
Â  Â  canvas {
Â  Â  Â  /* ç§»é™¤è¾¹æ¡†å’Œé˜´å½±ï¼Œä½¿å…¶å æ»¡å…¨å± */
Â  Â  Â  display: block;
      width: 100vw;
      height: 100vh;
Â  Â  Â  background-color: #141428;
      cursor: crosshair; /* é»˜è®¤æ˜¾ç¤ºå‡†æ˜Ÿ */
Â  Â  }

Â  Â  /* é¼ æ ‡æ ·å¼ï¼Œæç¤ºç©å®¶å¯ä»¥å°„å‡»/äº’åŠ¨ */
Â  Â  canvas:active {
Â  Â  Â  cursor: crosshair;
Â  Â  }

    /* èœå•ä¸­çš„å¯ç‚¹å‡»å…ƒç´  */
    canvas.menu-hover {
      cursor: pointer;
    }

Â  Â  /* éŸ³ä¹æ§åˆ¶æŒ‰é’®æ ·å¼ */
Â  Â  #music-control {
Â  Â  Â  position: absolute;
Â  Â  Â  bottom: 20px;
Â  Â  Â  right: 20px; /* å®šä½åˆ°è§†å£å³ä¸‹è§’ */
Â  Â  Â  background-color: rgba(255, 215, 0, 0.9);
Â  Â  Â  color: #141428;
Â  Â  Â  border: 2px solid #FFD700;
Â  Â  Â  border-radius: 8px;
Â  Â  Â  padding: 10px 15px;
Â  Â  Â  font-size: 20px;
Â  Â  Â  font-weight: bold;
Â  Â  Â  cursor: pointer;
Â  Â  Â  transition: background-color 0.2s, transform 0.1s;
Â  Â  Â  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      z-index: 100;
Â  Â  }

Â  Â  #music-control:hover {
Â  Â  Â  background-color: #FFF;
Â  Â  }

Â  Â  #music-control:active {
Â  Â  Â  transform: scale(0.98);
Â  Â  }
Â  </style>
</head>
<body>
<!-- ç§»é™¤å›ºå®šçš„ width å’Œ height å±æ€§ -->
<canvas id="gameCanvas"></canvas>

<!-- éŸ³é¢‘å…ƒç´ ï¼šè®¾ç½® autoplay å’Œ loop -->
<audio id="backgroundMusic" loop>
Â  <source src="https://example.com/your-awesome-game-music.mp3" type="audio/mp3">
Â  æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾ã€‚
</audio>

<button id="music-control">
Â  ğŸ”Š éŸ³ä¹: å¼€å¯
</button>

<script>
Â  // --------------------------------------------------------
Â  // ğŸ“ ä»£ç ç»“æ„ï¼šDANTAO - æ— å°½Waveå¢å¼ºç‰ˆ (å•æ–‡ä»¶ JS å®ç°)
Â  // --------------------------------------------------------

Â  // === å…¨å±€å¸¸é‡ ===
  // å˜ä¸ºåŠ¨æ€å˜é‡
Â  let CANVAS_WIDTH = window.innerWidth;
Â  let CANVAS_HEIGHT = window.innerHeight;
Â  const FPS = 60;
Â  const BACKGROUND_COLOR = 'rgb(20, 20, 40)';
Â  const GRID_COLOR = 'rgb(40, 40, 60)';
Â  const SHOCKWAVE_COOLDOWN = 10.0; // Eé”®æŠ€èƒ½å†·å´æ—¶é—´ (ç§’)

Â  // çŠ¶æ€æœº
Â  const GameState = {
Â  Â  MENU: 'menu',
Â  Â  GAME: 'game',
Â  Â  LEVEL_UP: 'level_up',
Â  Â  GAME_OVER: 'game_over'
Â  };

Â  // çš®è‚¤é¢œè‰²
Â  const SkinColors = {
Â  Â  default: 'rgb(0, 255, 0)',
Â  Â  blue: 'rgb(0, 100, 255)',
Â  Â  red: 'rgb(255, 50, 50)',
Â  Â  gold: 'rgb(255, 215, 0)'
Â  };

Â  // --------------------------------------------------------
Â  // 1. Data/PlayerData.js - æ•°æ®æŒä¹…åŒ–
Â  // --------------------------------------------------------
Â  class PlayerData {
Â  Â  constructor() {
Â  Â  Â  this.coins = 0;
Â  Â  Â  this.ownedSkins = ['default', 'blue', 'red', 'gold']; // é»˜è®¤è§£é”æ‰€æœ‰çš®è‚¤
Â  Â  Â  this.currentSkin = 'default';
Â  Â  Â  this.highScore = 0;
Â  Â  Â  this.loadData();
Â  Â  }

Â  Â  loadData() {
Â  Â  Â  try {
Â  Â  Â  Â  // PCç«¯ä½¿ç”¨ localStorage æ›¿ä»£ sessionStorage ä»¥ä¾¿æŒä¹…åŒ–
Â  Â  Â  Â  const dataString = localStorage.getItem('dantao_player_data');
Â  Â  Â  Â  if (dataString) {
Â  Â  Â  Â  Â  const data = JSON.parse(dataString);
Â  Â  Â  Â  Â  this.coins = data.coins || 0;
Â  Â  Â  Â  Â  this.ownedSkins = data.owned_skins || ['default', 'blue', 'red', 'gold']; // åŠ è½½æ—¶ä¹Ÿç¡®ä¿
Â  Â  Â  Â  Â  this.currentSkin = data.current_skin || 'default';
Â  Â  Â  Â  Â  this.highScore = data.highScore || 0;
Â  Â  Â  Â  }
Â  Â  Â  } catch (e) {
Â  Â  Â  Â  console.error("åŠ è½½æ•°æ®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:", e);
Â  Â  Â  }
Â  Â  }

Â  Â  saveData() {
Â  Â  Â  const data = {
Â  Â  Â  Â  coins: this.coins,
Â  Â  Â  Â  owned_skins: this.ownedSkins,
Â  Â  Â  Â  current_skin: this.currentSkin,
Â  Â  Â  Â  highScore: this.highScore
Â  Â  Â  };
Â  Â  Â  localStorage.setItem('dantao_player_data', JSON.stringify(data));
Â  Â  }

Â  Â  addCoins(amount) {
Â  Â  Â  this.coins += amount;
Â  Â  Â  this.saveData();
Â  Â  }

Â  Â  updateHighScore(score) {
Â  Â  Â  if (score > this.highScore) {
Â  Â  Â  Â  this.highScore = score;
Â  Â  Â  Â  this.saveData();
Â  Â  Â  }
Â  Â  }

Â  Â  getSkinColor() {
Â  Â  Â  return SkinColors[this.currentSkin] || SkinColors.default;
Â  Â  }
Â  }

Â  // --------------------------------------------------------
Â  // 2. Systems/CollisionManager.js - ç¢°æ’ç³»ç»Ÿ
Â  // --------------------------------------------------------
Â  class CollisionManager {
Â  Â  static checkCircleCollision(e1, e2) {
Â  Â  Â  const dx = e1.x - e2.x;
Â  Â  Â  const dy = e1.y - e2.y;
Â  Â  Â  const distanceSq = dx * dx + dy * dy;
Â  Â  Â  const radiiSum = e1.radius + e2.radius;
Â  Â  Â  return distanceSq < radiiSum * radiiSum;
Â  Â  }

Â  Â  static checkAndResolve(entity, targetRect) {
Â  Â  Â  const radius = entity.radius || (entity.width ? entity.width / 2 : 30);

Â  Â  Â  const eRect = {
Â  Â  Â  Â  left: entity.x - radius,
Â  Â  Â  Â  right: entity.x + radius,
Â  Â  Â  Â  top: entity.y - radius,
Â  Â  Â  Â  bottom: entity.y + radius
Â  Â  Â  };

Â  Â  Â  const tRect = targetRect;

Â  Â  Â  const overlapX = Math.max(0, Math.min(eRect.right, tRect.x + tRect.width) - Math.max(eRect.left, tRect.x));
Â  Â  Â  const overlapY = Math.max(0, Math.min(eRect.bottom, tRect.y + tRect.height) - Math.max(eRect.top, tRect.y));

Â  Â  Â  if (overlapX > 0 && overlapY > 0) {
Â  Â  Â  Â  if (overlapX < overlapY) {
Â  Â  Â  Â  Â  if (eRect.left < tRect.x) {
Â  Â  Â  Â  Â  Â  entity.x -= overlapX;
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  entity.x += overlapX;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  if (eRect.top < tRect.y) {
Â  Â  Â  Â  Â  Â  entity.y -= overlapY;
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  entity.y += overlapY;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return true;
Â  Â  Â  }
Â  Â  Â  return false;
Â  Â  }
Â  }

Â  // --------------------------------------------------------
Â  // 3. Systems/Camera.js - æ‘„åƒæœºç³»ç»Ÿ
Â  // --------------------------------------------------------
Â  class Camera {
Â  Â  constructor(width, height) {
Â  Â  Â  this.width = width;
Â  Â  Â  this.height = height;
Â  Â  Â  this.x = 0;
Â  Â  Â  this.y = 0;
Â  Â  Â  this.smoothness = 0.08;
Â  Â  }

Â  Â  update(target, dt) {
Â  Â  Â  const targetX = target.x - this.width / 2;
Â  Â  Â  const targetY = target.y - this.height / 2;

Â  Â  Â  this.x += (targetX - this.x) * this.smoothness;
Â  Â  Â  this.y += (targetY - this.y) * this.smoothness;
Â  Â  }

Â  Â  worldToScreen(worldX, worldY) {
Â  Â  Â  return {
Â  Â  Â  Â  x: worldX - this.x,
Â  Â  Â  Â  y: worldY - this.y
Â  Â  Â  };
Â  Â  }

Â  Â  getViewport() {
Â  Â  Â  const inflate = 200;
Â  Â  Â  return {
Â  Â  Â  Â  left: this.x - inflate,
Â  Â  Â  Â  top: this.y - inflate,
Â  Â  Â  Â  right: this.x + this.width + inflate,
Â  Â  Â  Â  bottom: this.y + this.height + inflate
Â  Â  Â  };
Â  Â  }
Â  }

Â  // --------------------------------------------------------
Â  // 4. Systems/RNG.js (Helper) & InfiniteWorld.js - ä¸–ç•Œç”Ÿæˆ
Â  // --------------------------------------------------------

Â  class SeededRNG {
Â  Â  constructor(seed) {
Â  Â  Â  this.seed = seed % 2147483647;
Â  Â  Â  if (this.seed <= 0) this.seed += 2147483646;
Â  Â  }

Â  Â  next() {
Â  Â  Â  this.seed = (this.seed * 16807) % 2147483647;
Â  Â  Â  return (this.seed - 1) / 2147483646;
Â  Â  }

Â  Â  randFloat(min = 0, max = 1) {
Â  Â  Â  return min + this.next() * (max - min);
Â  Â  }

Â  Â  randInt(min, max) {
Â  Â  Â  return Math.floor(this.randFloat(min, max + 1));
Â  Â  }

Â  Â  choice(arr) {
Â  Â  Â  return arr[this.randInt(0, arr.length - 1)];
Â  Â  }
Â  }

Â  class Building {
Â  Â  constructor(x, y, width, height, type) {
Â  Â  Â  this.x = x;
Â  Â  Â  this.y = y;
Â  Â  Â  this.width = width;
Â  Â  Â  this.height = height;
Â  Â  Â  this.type = type;
Â  Â  Â  this.health = type === 'wood' ? 50 : 150;
Â  Â  Â  this.maxHealth = this.health;
Â  Â  Â  this.isHazard = type === 'spike' || type === 'fire';
Â  Â  Â  this.isDestroyable = !this.isHazard;
Â  Â  Â  this.damage = this.isHazard ? (type === 'spike' ? 15 : 20) : 0;

Â  Â  Â  this.color = this._getColor(type);
Â  Â  Â  this.isAlive = true;
Â  Â  }

Â  Â  _getColor(type) {
Â  Â  Â  switch (type) {
Â  Â  Â  Â  case 'wood': return 'rgb(139, 69, 19)';
Â  Â  Â  Â  case 'stone': return 'rgb(100, 100, 100)';
Â  Â  Â  Â  case 'spike': return 'rgb(150, 50, 50)';
Â  Â  Â  Â  case 'fire': return 'rgb(255, 100, 0)';
Â  Â  Â  Â  default: return 'gray';
Â  Â  Â  }
Â  Â  }

Â  Â  takeDamage(damage) {
Â  Â  Â  if (this.isDestroyable) {
Â  Â  Â  Â  this.health -= damage;
Â  Â  Â  Â  if (this.health <= 0) {
Â  Â  Â  Â  Â  this.isAlive = false;
Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  return false;
Â  Â  }

Â  Â  draw(ctx, offset) {
Â  Â  Â  const screenPos = {
Â  Â  Â  Â  x: this.x - offset.x,
Â  Â  Â  Â  y: this.y - offset.y
Â  Â  Â  };

Â  Â  Â  ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
Â  Â  Â  ctx.fillRect(screenPos.x + 5, screenPos.y + 5, this.width, this.height);

Â  Â  Â  ctx.fillStyle = this.color;
Â  Â  Â  ctx.fillRect(screenPos.x, screenPos.y, this.width, this.height);

Â  Â  Â  if (this.type === 'spike') {
Â  Â  Â  Â  ctx.fillStyle = 'black';
Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  for (let i = 0; i < 5; i++) {
Â  Â  Â  Â  Â  ctx.moveTo(screenPos.x + i * (this.width / 5), screenPos.y);
Â  Â  Â  Â  Â  ctx.lineTo(screenPos.x + (i * (this.width / 5)) + (this.width / 10), screenPos.y - 10);
Â  Â  Â  Â  Â  ctx.lineTo(screenPos.x + (i + 1) * (this.width / 5), screenPos.y);
Â  Â  Â  Â  }
Â  Â  Â  Â  ctx.fill();
Â  Â  Â  }
Â  Â  }
Â  }

Â  class InfiniteWorld {
Â  Â  constructor() {
Â  Â  Â  this.chunkSize = 1000;
Â  Â  Â  this.chunks = new Map();
Â  Â  Â  this.typeDistribution = [
Â  Â  Â  Â  { type: 'wood', prob: 0.40 },
Â  Â  Â  Â  { type: 'stone', prob: 0.30 },
Â  Â  Â  Â  { type: 'spike', prob: 0.15 },
Â  Â  Â  Â  { type: 'fire', prob: 0.15 }
Â  Â  Â  ];
Â  Â  }

Â  Â  getChunkCoords(worldX, worldY) {
Â  Â  Â  const chunkX = Math.floor(worldX / this.chunkSize);
Â  Â  Â  const chunkY = Math.floor(worldY / this.chunkSize);
Â  Â  Â  return { x: chunkX, y: chunkY };
Â  Â  }

Â  Â  getChunkKey(x, y) {
Â  Â  Â  return `${x},${y}`;
Â  Â  }

Â  Â  getVisibleContent(player) {
Â  Â  Â  const { x: pX, y: pY } = this.getChunkCoords(player.x, player.y);
Â  Â  Â  const visibleBuildings = [];
Â  Â  Â  const visibleChunkKeys = [];
Â  Â  Â  const loadDistance = 2;

Â  Â  Â  for (let i = -loadDistance; i <= loadDistance; i++) {
Â  Â  Â  Â  for (let j = -loadDistance; j <= loadDistance; j++) {
Â  Â  Â  Â  Â  const chunkX = pX + i;
Â  Â  Â  Â  Â  const chunkY = pY + j;
Â  Â  Â  Â  Â  const key = this.getChunkKey(chunkX, chunkY);
Â  Â  Â  Â  Â  visibleChunkKeys.push({ x: chunkX, y: chunkY });

Â  Â  Â  Â  Â  if (!this.chunks.has(key)) {
Â  Â  Â  Â  Â  Â  this.generateChunk(chunkX, chunkY);
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  visibleBuildings.push(...this.chunks.get(key).buildings.filter(b => b.isAlive));
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  return {
Â  Â  Â  Â  buildings: visibleBuildings,
Â  Â  Â  Â  chunkKeys: visibleChunkKeys
Â  Â  Â  };
Â  Â  }

Â  Â  generateChunk(chunkX, chunkY) {
Â  Â  Â  const key = this.getChunkKey(chunkX, chunkY);
Â  Â  Â  const seed = (chunkX * 10000 + chunkY) * 12345;
Â  Â  Â  const rng = new SeededRNG(seed);

Â  Â  Â  const buildings = [];
Â  Â  Â  const numBuildings = rng.randInt(10, 25);

Â  Â  Â  const originX = chunkX * this.chunkSize;
Â  Â  Â  const originY = chunkY * this.chunkSize;
Â  Â  Â  const padding = 50;

Â  Â  Â  for (let i = 0; i < numBuildings; i++) {
Â  Â  Â  Â  const typeIndex = this._getWeightedRandomType(rng);
Â  Â  Â  Â  const type = this.typeDistribution[typeIndex].type;

Â  Â  Â  Â  const width = rng.randInt(60, 120);
Â  Â  Â  Â  const height = rng.randInt(60, 120);

Â  Â  Â  Â  const x = originX + rng.randInt(padding, this.chunkSize - width - padding);
Â  Â  Â  Â  const y = originY + rng.randInt(padding, this.chunkSize - height - padding);

Â  Â  Â  Â  buildings.push(new Building(x, y, width, height, type));
Â  Â  Â  }

Â  Â  Â  this.chunks.set(key, { buildings: buildings, enemies: [] });
Â  Â  }

Â  Â  _getWeightedRandomType(rng) {
Â  Â  Â  const total = this.typeDistribution.reduce((sum, item) => sum + item.prob, 0);
Â  Â  Â  let rand = rng.randFloat(0, total);

Â  Â  Â  for (let i = 0; i < this.typeDistribution.length; i++) {
Â  Â  Â  Â  rand -= this.typeDistribution[i].prob;
Â  Â  Â  Â  if (rand <= 0) {
Â  Â  Â  Â  Â  return i;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  return 0;
Â  Â  }

Â  Â  getChunkWorldBounds(chunkX, chunkY) {
Â  Â  Â  const originX = chunkX * this.chunkSize;
Â  Â  Â  const originY = chunkY * this.chunkSize;
Â  Â  Â  return {
Â  Â  Â  Â  x: originX,
Â  Â  Â  Â  y: originY,
Â  Â  Â  Â  width: this.chunkSize,
Â  Â  Â  Â  height: this.chunkSize
Â  Â  Â  };
Â  Â  }
Â  }


Â  // --------------------------------------------------------
Â  // 5. Entities/Player.js - ç©å®¶å®ä½“
Â  // --------------------------------------------------------
Â  class Player {
Â  Â  constructor(x, y, data) {
Â  Â  Â  this.x = x;
Â  Â  Â  this.y = y;
Â  Â  Â  this.radius = 30;
Â  Â  Â  this.data = data;
Â  Â  Â  this.level = 1;
Â  Â  Â  this.score = 0;

Â  Â  Â  this.maxHealth = 100;
Â  Â  Â  this.health = 100;
Â  Â  Â  this.baseSpeed = 250;
Â  Â  Â  this.baseDamage = 15;

Â  Â  Â  this.damageMultiplier = 1.0;
Â  Â  Â  this.speedMultiplier = 1.0;

Â  Â  Â  this.isAlive = true;
Â  Â  Â  this.isInvincible = false;
Â  Â  Â  this.invincibilityTimer = 0;
Â  Â  Â  this.invincibilityDuration = 0.5;
Â  Â  Â  this.lastAttackTime = 0;
Â  Â  Â  this.attackCooldown = 0.25;

Â  Â  Â  // --- E (Shockwave) Skill ---
Â  Â  Â  this.shockwaveCooldown = 0;
Â  Â  Â  this.shockwaveMaxCooldown = SHOCKWAVE_COOLDOWN; // 10.0s
Â  Â  Â  this.shockwaveRadius = 500;
Â  Â  Â  this.shockwaveDamage = 100;
Â  Â  Â  this.isShockwaving = false;
Â  Â  Â  this.shockwaveTimer = 0.0;
Â  Â  Â  this.shockwaveDuration = 0.2;

Â  Â  Â  // --- Q (Shield) Skill - çŸ­æš‚æ— æ•ŒæŠ¤ç›¾ ---
Â  Â  Â  this.shieldCooldown = 0;
Â  Â  Â  this.shieldMaxCooldown = 15.0; // 15s å†·å´
Â  Â  Â  this.isShielded = false;
Â  Â  Â  this.shieldDuration = 2.0; // 2s æŒç»­æ—¶é—´ (é‡ç½®å€¼)

Â  Â  Â  // --- C (Damage Buff) Skill - çŸ­æš‚å¢ä¼¤ ---
Â  Â  Â  this.buffCooldown = 0;
Â  Â  Â  this.buffMaxCooldown = 20.0; // 20s å†·å´
Â  Â  Â  this.isBuffed = false;
Â  Â  Â  this.buffDuration = 5.0; // 5s æŒç»­æ—¶é—´ (é‡ç½®å€¼)
Â  Â  Â  this.baseBuffMultiplier = 1.0; // 100% ä¼¤å®³åŠ æˆ (æ€»ä¹˜æ•° * 2.0)

Â  Â  Â  this.exp = 0;
Â  Â  Â  this.expToNextLevel = 100;
Â  Â  Â  this.expGrowthRate = 1.4;

Â  Â  Â  this.aimAngle = 0;

      // å‡»é€€
      this.knockbackVelX = 0;
      this.knockbackVelY = 0;
      
      // å‡é€Ÿ
      this.isSlowed = false;
      this.slowTimer = 0;
      this.slowDuration = 2.0; // é»˜è®¤å‡é€Ÿ2ç§’
Â  Â  }

Â  Â  // --- Q æŠ€èƒ½ (æŠ¤ç›¾) ---
Â  Â  useShield(currentTime) {
Â  Â  Â  if (this.shieldCooldown <= 0) {
Â  Â  Â  Â  this.shieldCooldown = this.shieldMaxCooldown;
Â  Â  Â  Â  this.isShielded = true;
Â  Â  Â  Â  this.shieldDuration = 2.0; // å¯åŠ¨æ—¶é‡ç½®æŒç»­æ—¶é—´
Â  Â  Â  Â  return true;
Â  Â  Â  }
Â  Â  Â  return false;
Â  Â  }

Â  Â  // --- C æŠ€èƒ½ (å¢ä¼¤) ---
Â  Â  useDamageBuff(currentTime) {
Â  Â  Â  if (this.buffCooldown <= 0) {
Â  Â  Â  Â  this.buffCooldown = this.buffMaxCooldown;
Â  Â  Â  Â  this.isBuffed = true;
Â  Â  Â  Â  this.damageMultiplier += this.baseBuffMultiplier; // å¢åŠ ä¼¤å®³ä¹˜æ•° (1.0 -> 2.0)
Â  Â  Â  Â  this.buffDuration = 5.0; // å¯åŠ¨æ—¶é‡ç½®æŒç»­æ—¶é—´
Â  Â  Â  Â  return true;
Â  Â  Â  }
Â  Â  Â  return false;
Â  Â  }

Â  Â  useShockwave(currentTime) {
Â  Â  Â  if (this.shockwaveCooldown <= 0) {
Â  Â  Â  Â  this.shockwaveCooldown = this.shockwaveMaxCooldown;
Â  Â  Â  Â  this.isShockwaving = true;
Â  Â  Â  Â  this.shockwaveTimer = this.shockwaveDuration;
Â  Â  Â  Â  return true;
Â  Â  Â  }
Â  Â  Â  return false;
Â  Â  }

    // ç”±æ•Œäººè°ƒç”¨çš„å‡»é€€
    applyKnockback(angle, force) {
      // æŠ¤ç›¾å¯ä»¥æŠµæŒ¡å‡»é€€
      if (this.isShielded) return; 
      this.knockbackVelX = Math.cos(angle) * force;
      this.knockbackVelY = Math.sin(angle) * force;
    }

    // ç”±æ•Œäººè°ƒç”¨çš„å‡é€Ÿ
    applySlow(duration) {
        if (this.isShielded) return; // æŠ¤ç›¾æŠµæŒ¡å‡é€Ÿ
        this.isSlowed = true;
        this.slowTimer = duration;
    }

Â  Â  gainExp(amount) {
Â  Â  Â  this.exp += amount;
Â  Â  Â  while (this.exp >= this.expToNextLevel) {
Â  Â  Â  Â  this.levelUp();
Â  Â  Â  }
Â  Â  }

Â  Â  levelUp() {
Â  Â  Â  this.level += 1;
Â  Â  Â  this.exp -= this.expToNextLevel;
Â  Â  Â  this.expToNextLevel = Math.floor(100 * (this.expGrowthRate ** this.level));

Â  Â  Â  this.health += this.maxHealth * 0.3;
Â  Â  Â  if (this.health > this.maxHealth) this.health = this.maxHealth;

Â  Â  Â  gameInstance.setState(GameState.LEVEL_UP);
Â  Â  }

Â  Â  applyUpgrade(type) {
Â  Â  Â  switch(type) {
Â  Â  Â  Â  case 'damage':
Â  Â  Â  Â  Â  this.damageMultiplier += 0.25;
Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  case 'health':
Â  Â  Â  Â  Â  this.maxHealth += 30;
Â  Â  Â  Â  Â  this.health += 30;
Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  case 'speed':
Â  Â  Â  Â  Â  this.speedMultiplier += 0.15;
Â  Â  Â  Â  Â  break;
Â  Â  Â  }
Â  Â  Â  gameInstance.setState(GameState.GAME);
Â  Â  }

Â  Â  takeDamage(damage) {
Â  Â  Â  // 1. æ£€æŸ¥æŠ¤ç›¾ (Q æŠ€èƒ½)
Â  Â  Â  if (this.isShielded) {
Â  Â  Â  Â  // æŠ¤ç›¾å¸æ”¶ä¼¤å®³ï¼Œä¸è§¦å‘çŸ­æš‚æ— æ•Œ
Â  Â  Â  Â  return true;
Â  Â  Â  }

Â  Â  Â  // 2. æ£€æŸ¥çŸ­æš‚æ— æ•Œ (ç”±ä¼¤å®³è§¦å‘)
Â  Â  Â  if (!this.isAlive || this.isInvincible) return false;

Â  Â  Â  this.health -= damage;

Â  Â  Â  this.isInvincible = true;
Â  Â  Â  this.invincibilityTimer = this.invincibilityDuration;

Â  Â  Â  if (this.health <= 0) {
Â  Â  Â  Â  this.health = 0;
Â  Â  Â  Â  this.isAlive = false;
Â  Â  Â  Â  gameInstance.setState(GameState.GAME_OVER);
Â  Â  Â  }
Â  Â  Â  return true;
Â  Â  }

Â  Â  attack(currentTime, targetX, targetY) {
Â  Â  Â  if (currentTime >= this.lastAttackTime + this.attackCooldown) {
Â  Â  Â  Â  this.lastAttackTime = currentTime;

Â  Â  Â  Â  // finalDamage åŒ…å«äº† Level Up çš„ damageMultiplier å’Œ C-Skill çš„ buffMultiplier
Â  Â  Â  Â  const finalDamage = this.baseDamage * this.damageMultiplier;
Â  Â  Â  Â  const speed = 600;

Â  Â  Â  Â  const dx = targetX - this.x;
Â  Â  Â  Â  const dy = targetY - this.y;
Â  Â  Â  Â  this.aimAngle = Math.atan2(dy, dx);

Â  Â  Â  Â  return new Projectile(this.x, this.y, this.aimAngle, speed, finalDamage, this, 'player');
Â  Â  Â  }
Â  Â  Â  return null;
Â  Â  }

Â  Â  handleInput(input, dt) {
Â  Â  Â  let velX = 0;
Â  Â  Â  let velY = 0;
      
      // å‡é€Ÿé€»è¾‘
      let speedMod = this.speedMultiplier;
      if (this.isSlowed) {
          speedMod *= 0.5; // 50% å‡é€Ÿ
      }
Â  Â  Â  const currentSpeed = this.baseSpeed * speedMod;

Â  Â  Â  if (input.keys['w']) velY -= 1;
Â  Â  Â  if (input.keys['s']) velY += 1;
Â  Â  Â  if (input.keys['a']) velX -= 1;
Â  Â  Â  if (input.keys['d']) velX += 1;

Â  Â  Â  if (gameInstance.state === GameState.GAME) {
Â  Â  Â  Â  // E æŠ€èƒ½è¾“å…¥
Â  Â  Â  Â  if (input.keys['e']) {
Â  Â  Â  Â  Â  this.useShockwave(gameInstance.currentTime);
Â  Â  Â  Â  }
Â  Â  Â  Â  // Q æŠ€èƒ½è¾“å…¥ (æŠ¤ç›¾)
Â  Â  Â  Â  if (input.keys['q']) {
Â  Â  Â  Â  Â  this.useShield(gameInstance.currentTime);
Â  Â  Â  Â  }
Â  Â  Â  Â  // C æŠ€èƒ½è¾“å…¥ (å¢ä¼¤)
Â  Â  Â  Â  if (input.keys['c']) {
Â  Â  Â  Â  Â  this.useDamageBuff(gameInstance.currentTime);
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  if (velX !== 0 || velY !== 0) {
Â  Â  Â  Â  const magnitude = Math.sqrt(velX * velX + velY * velY);
Â  Â  Â  Â  velX /= magnitude;
Â  Â  Â  Â  velY /= magnitude;
Â  Â  Â  }

Â  Â  Â  this.x += velX * currentSpeed * dt;
Â  Â  Â  this.y += velY * currentSpeed * dt;

      // åº”ç”¨å‡»é€€
      this.x += this.knockbackVelX * dt;
      this.y += this.knockbackVelY * dt;
      
      const decayRate = 0.9;
      this.knockbackVelX *= decayRate;
      this.knockbackVelY *= decayRate;
      if (Math.abs(this.knockbackVelX) < 10) this.knockbackVelX = 0;
      if (Math.abs(this.knockbackVelY) < 10) this.knockbackVelY = 0;

Â  Â  Â  const dx = input.mouse.worldX - this.x;
Â  Â  Â  const dy = input.mouse.worldY - this.y;
Â  Â  Â  this.aimAngle = Math.atan2(dy, dx);
Â  Â  }

Â  Â  update(dt) {
Â  Â  Â  this.score += 1 * dt;

Â  Â  Â  // Invincibility update
Â  Â  Â  if (this.isInvincible) {
Â  Â  Â  Â  this.invincibilityTimer -= dt;
Â  Â  Â  Â  if (this.invincibilityTimer <= 0) {
Â  Â  Â  Â  Â  this.isInvincible = false;
Â  Â  Â  Â  }
Â  Â  Â  }

      // Slow effect update
      if (this.isSlowed) {
          this.slowTimer -= dt;
          if (this.slowTimer <= 0) {
              this.isSlowed = false;
          }
      }

Â  Â  Â  // E Skill Cooldown/Timer update
Â  Â  Â  if (this.shockwaveCooldown > 0) {
Â  Â  Â  Â  this.shockwaveCooldown -= dt;
Â  Â  Â  }

Â  Â  Â  if (this.isShockwaving) {
Â  Â  Â  Â  this.shockwaveTimer -= dt;
Â  Â  Â  Â  if (this.shockwaveTimer <= 0) {
Â  Â  Â  Â  Â  this.isShockwaving = false;
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  // Q Skill Cooldown/Timer update (Shield)
Â  Â  Â  if (this.shieldCooldown > 0) {
Â  Â  Â  Â  this.shieldCooldown -= dt;
Â  Â  Â  }
Â  Â  Â  if (this.isShielded) {
Â  Â  Â  Â  this.shieldDuration -= dt;
Â  Â  Â  Â  if (this.shieldDuration <= 0) {
Â  Â  Â  Â  Â  this.isShielded = false;
Â  Â  Â  Â  Â  this.shieldDuration = 2.0; // Reset duration for next use
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  // C Skill Cooldown/Timer update (Damage Buff)
Â  Â  Â  if (this.buffCooldown > 0) {
Â  Â  Â  Â  this.buffCooldown -= dt;
Â  Â  Â  }
Â  Â  Â  if (this.isBuffed) {
Â  Â  Â  Â  this.buffDuration -= dt;
Â  Â  Â  Â  if (this.buffDuration <= 0) {
Â  Â  Â  Â  Â  this.isBuffed = false;
Â  Â  Â  Â  Â  this.damageMultiplier -= this.baseBuffMultiplier; // ç§»é™¤ä¼¤å®³åŠ æˆ
Â  Â  Â  Â  Â  this.buffDuration = 5.0; // Reset duration for next use
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  gameInstance.buildings.forEach(b => {
Â  Â  Â  Â  const trapContact = {
Â  Â  Â  Â  Â  x: b.x + b.width / 2,
Â  Â  Â  Â  Â  y: b.y + b.height / 2,
Â  Â  Â  Â  Â  radius: Math.min(b.width, b.height) / 2
Â  Â  Â  Â  };
Â  Â  Â  Â  if (b.isHazard && CollisionManager.checkCircleCollision(this, trapContact)) {
Â  Â  Â  Â  Â  this.takeDamage(b.damage * dt);
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  }

Â  Â  draw(ctx, offset) {
Â  Â  Â  const screenPos = gameInstance.camera.worldToScreen(this.x, this.y);

Â  Â  Â  // --- Q æŠ€èƒ½æŠ¤ç›¾æ•ˆæœ ---
Â  Â  Â  if (this.isShielded) {
Â  Â  Â  Â  const radius = this.radius * 1.5;
Â  Â  Â  Â  const flash = Math.abs(Math.sin(gameInstance.currentTime * 10)); // è„‰å†²æ•ˆæœ

Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
Â  Â  Â  Â  ctx.strokeStyle = `rgba(0, 150, 255, ${0.5 + flash * 0.3})`;
Â  Â  Â  Â  ctx.lineWidth = 8;
Â  Â  Â  Â  ctx.stroke();

Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  ctx.arc(screenPos.x, screenPos.y, this.radius + 5, 0, Math.PI * 2);
Â  Â  Â  Â  ctx.fillStyle = `rgba(0, 100, 255, 0.4)`;
Â  Â  Â  Â  ctx.fill();
Â  Â  Â  }

Â  Â  Â  // --- E æŠ€èƒ½å†²å‡»æ³¢æ•ˆæœ ---
Â  Â  Â  if (this.isShockwaving) {
Â  Â  Â  Â  const progress = 1 - (this.shockwaveTimer / this.shockwaveDuration);
Â  Â  Â  Â  const currentRadius = progress * this.shockwaveRadius;

Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  ctx.arc(screenPos.x, screenPos.y, currentRadius, 0, Math.PI * 2);

Â  Â  Â  Â  const alpha = 0.5 - progress * 0.5;
Â  Â  Â  Â  ctx.strokeStyle = `rgba(200, 200, 255, ${alpha})`;
Â  Â  Â  Â  ctx.lineWidth = 15 + (1 - progress) * 20;
Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  }

Â  Â  Â  const isFlashing = this.isInvincible && (Math.floor(this.invincibilityTimer * 10) % 2 === 0);
      let playerColor = this.data.getSkinColor();
      if (this.isSlowed) {
          playerColor = 'rgb(100, 100, 255)'; // å‡é€Ÿæ—¶æ˜¾ç¤ºä¸ºè“è‰²
      }

Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
Â  Â  Â  ctx.fillStyle = isFlashing ? 'white' : playerColor;
Â  Â  Â  ctx.fill();

Â  Â  Â  ctx.strokeStyle = 'black';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();

Â  Â  Â  // --- C æŠ€èƒ½å¢ä¼¤æ•ˆæœ ---
Â  Â  Â  if (this.isBuffed) {
Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  ctx.arc(screenPos.x, screenPos.y, this.radius * 0.8, 0, Math.PI * 2);
Â  Â  Â  Â  ctx.strokeStyle = 'rgba(255, 100, 0, 0.8)';
Â  Â  Â  Â  ctx.lineWidth = 5;
Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  }

Â  Â  Â  const eyeRadius = 12;
Â  Â  Â  const pupilRadius = 6;
Â  Â  Â  const eyeOffset = 10;

Â  Â  Â  const eyeX = screenPos.x + Math.cos(this.aimAngle) * (this.radius - eyeRadius);
Â  Â  Â  const eyeY = screenPos.y + Math.sin(this.aimAngle) * (this.radius - eyeRadius);

Â  Â  Â  const pupilX = eyeX + Math.cos(this.aimAngle) * eyeOffset;
Â  Â  Â  const pupilY = eyeY + Math.sin(this.aimAngle) * eyeOffset;

Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(eyeX, eyeY, eyeRadius, 0, Math.PI * 2);
Â  Â  Â  ctx.fillStyle = 'white';
Â  Â  Â  ctx.fill();

Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(pupilX, pupilY, pupilRadius, 0, Math.PI * 2);
Â  Â  Â  ctx.fillStyle = 'black';
Â  Â  Â  ctx.fill();
Â  Â  }
Â  }

Â  // --------------------------------------------------------
Â  // 6. Entities/Projectile.js - æŠ•å°„ç‰©ç³»ç»Ÿ
Â  // --------------------------------------------------------
Â  class Projectile {
Â  Â  constructor(x, y, angle, speed, damage, owner, type) {
Â  Â  Â  this.x = x;
Â  Â  Â  this.y = y;
Â  Â  Â  this.angle = angle;
Â  Â  Â  this.speed = speed;
Â  Â  Â  this.damage = damage;
Â  Â  Â  this.owner = owner;
Â  Â  Â  this.type = type;
Â  Â  Â  this.radius = 8;
Â  Â  Â  this.velX = Math.cos(angle) * speed;
Â  Â  Â  this.velY = Math.sin(angle) * speed;
Â  Â  Â  this.lifetime = 3.0;
Â  Â  Â  this.isAlive = true;

Â  Â  Â  this.color = type === 'player' ? 'rgb(255, 215, 0)' : 'rgb(255, 50, 50)';
Â  Â  }

Â  Â  update(dt) {
Â  Â  Â  this.x += this.velX * dt;
Â  Â  Â  this.y += this.velY * dt;
Â  Â  Â  this.lifetime -= dt;

Â  Â  Â  if (this.lifetime <= 0) {
Â  Â  Â  Â  this.isAlive = false;
Â  Â  Â  }
Â  Â  }

Â  Â  draw(ctx, offset) {
Â  Â  Â  const screenPos = gameInstance.camera.worldToScreen(this.x, this.y);

Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(screenPos.x, screenPos.y, this.radius * 2, 0, Math.PI * 2);
Â  Â  Â  ctx.fillStyle = `rgba(${this.color.slice(4, -1)}, 0.2)`;
Â  Â  Â  ctx.fill();

Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
Â  Â  Â  ctx.fillStyle = this.color;
Â  Â  Â  ctx.fill();

Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(screenPos.x, screenPos.y, this.radius / 2, 0, Math.PI * 2);
Â  Â  Â  ctx.fillStyle = 'rgb(255, 255, 200)';
Â  Â  Â  ctx.fill();
Â  Â  }
Â  }

Â  // --------------------------------------------------------
Â  // 7. Entities/Enemy.js - æ•Œäººç³»ç»Ÿ
Â  // --------------------------------------------------------

Â  class EnemyBase {
Â  Â  constructor() {
Â  Â  Â  this.isAlive = true;
Â  Â  Â  this.knockbackVelX = 0;
Â  Â  Â  this.knockbackVelY = 0;
Â  Â  }

Â  Â  drawHealthBar(ctx, screenPos) {
Â  Â  Â  const barWidth = 40;
Â  Â  Â  const barHeight = 5;
Â  Â  Â  const healthRatio = this.health / this.maxHealth;

Â  Â  Â  ctx.fillStyle = 'rgb(100, 30, 30)';
Â  Â  Â  ctx.fillRect(screenPos.x - barWidth / 2, screenPos.y - this.radius - 15, barWidth, barHeight);

Â  Â  Â  ctx.fillStyle = healthRatio > 0.6 ? 'rgb(50, 255, 50)' : 'rgb(255, 200, 50)';
Â  Â  Â  ctx.fillRect(screenPos.x - barWidth / 2, screenPos.y - this.radius - 15, barWidth * healthRatio, barHeight);
Â  Â  }

Â  Â  applyKnockback(angle, force) {
Â  Â  Â  this.knockbackVelX = Math.cos(angle) * force;
Â  Â  Â  this.knockbackVelY = Math.sin(angle) * force;
Â  Â  }

Â  Â  updateMovement(dt, speed) {
Â  Â  Â  this.x += this.knockbackVelX * dt;
Â  Â  Â  this.y += this.knockbackVelY * dt;

Â  Â  Â  const decayRate = 0.9;
Â  Â  Â  this.knockbackVelX *= decayRate;
Â  Â  Â  this.knockbackVelY *= decayRate;

Â  Â  Â  if (Math.abs(this.knockbackVelX) < 10) this.knockbackVelX = 0;
Â  Â  Â  if (Math.abs(this.knockbackVelY) < 10) this.knockbackVelY = 0;
Â  Â  }
Â  }

Â  /** æ™®é€šå°„æ‰‹æ•Œäºº */
Â  class NormalShooter extends EnemyBase {
Â  Â  constructor(x, y) {
Â  Â  Â  super();
Â  Â  Â  this.x = x;
Â  Â  Â  this.y = y;
Â  Â  Â  this.radius = 25;
Â  Â  Â  this.maxHealth = 40;
Â  Â  Â  this.health = 40;
Â  Â  Â  this.speed = 100;
Â  Â  Â  this.damage = 8;
Â  Â  Â  this.expValue = 15;
Â  Â  Â  this.color = 'rgb(255, 100, 100)';
Â  Â  Â  this.attackCooldown = 2.0;
Â  Â  Â  this.lastAttackTime = 0;
Â  Â  Â  this.attackRange = 350;
Â  Â  Â  this.alertRange = 500;
Â  Â  }

Â  Â  takeDamage(damage) {
Â  Â  Â  this.health -= damage;
Â  Â  Â  if (this.health <= 0) {
Â  Â  Â  Â  this.isAlive = false;
Â  Â  Â  Â  gameInstance.player.gainExp(this.expValue);
Â  Â  Â  Â  gameInstance.player.score += this.expValue;
Â  Â  Â  Â  gameInstance.enemiesKilledThisWave += 1; // è®¡å…¥ WAVE å‡»æ€
Â  Â  Â  Â  return true;
Â  Â  Â  }
Â  Â  Â  return false;
Â  Â  }

Â  Â  update(dt, currentTime, target) {
Â  Â  Â  if (!this.isAlive) return;

Â  Â  Â  this.updateMovement(dt, this.speed);
Â  Â  Â  if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) return;

Â  Â  Â  const dx = target.x - this.x;
Â  Â  Â  const dy = target.y - this.y;
Â  Â  Â  const distance = Math.sqrt(dx * dx + dy * dy);
Â  Â  Â  const angle = Math.atan2(dy, dx);

Â  Â  Â  const speed = this.speed;

Â  Â  Â  if (distance < this.alertRange) {
Â  Â  Â  Â  let moveX = Math.cos(angle);
Â  Â  Â  Â  let moveY = Math.sin(angle);

Â  Â  Â  Â  if (distance < 200) {
Â  Â  Â  Â  Â  moveX *= -1;
Â  Â  Â  Â  Â  moveY *= -1;
Â  Â  Â  Â  } else if (distance > 300) {
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  moveX = 0;
Â  Â  Â  Â  Â  moveY = 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  this.x += moveX * speed * dt;
Â  Â  Â  Â  this.y += moveY * speed * dt;

Â  Â  Â  Â  if (distance < this.attackRange && currentTime >= this.lastAttackTime + this.attackCooldown) {
Â  Â  Â  Â  Â  this.lastAttackTime = currentTime;
Â  Â  Â  Â  Â  this.shoot(angle);
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }

Â  Â  shoot(angle) {
Â  Â  Â  const speed = 400;
Â  Â  Â  const damage = this.damage;
Â  Â  Â  const projectile = new Projectile(this.x, this.y, angle, speed, damage, this, 'enemy');
Â  Â  Â  gameInstance.projectiles.push(projectile);
Â  Â  }

Â  Â  draw(ctx, offset) {
Â  Â  Â  const screenPos = gameInstance.camera.worldToScreen(this.x, this.y);

Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
Â  Â  Â  ctx.fillStyle = this.color;
Â  Â  Â  ctx.fill();
Â  Â  Â  ctx.strokeStyle = 'black';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  ctx.stroke();

Â  Â  Â  this.drawHealthBar(ctx, screenPos);
Â  Â  }
Â  }

Â  /** å¿«é€Ÿè¿‘æˆ˜æ•Œäºº */
Â  class FastMeleeEnemy extends EnemyBase {
Â  Â  constructor(x, y) {
Â  Â  Â  super();
Â  Â  Â  this.x = x;
Â  Â  Â  this.y = y;
Â  Â  Â  this.width = 30;
Â  Â  Â  this.height = 30;
Â  Â  Â  this.radius = 20;
Â  Â  Â  this.maxHealth = 20;
Â  Â  Â  this.health = 20;
Â  Â  Â  this.speed = 350;
Â  Â  Â  this.damage = 5;
Â  Â  Â  this.expValue = 8;
Â  Â  Â  this.color = 'rgb(50, 255, 255)';
Â  Â  }

Â  Â  takeDamage(damage) {
Â  Â  Â  this.health -= damage;
Â  Â  Â  if (this.health <= 0) {
Â  Â  Â  Â  this.isAlive = false;
Â  Â  Â  Â  gameInstance.player.gainExp(this.expValue);
Â  Â  Â  Â  gameInstance.player.score += this.expValue;
Â  Â  Â  Â  gameInstance.enemiesKilledThisWave += 1; // è®¡å…¥ WAVE å‡»æ€
Â  Â  Â  Â  return true;
Â  Â  Â  }
Â  Â  Â  return false;
Â  Â  }

Â  Â  update(dt, currentTime, target) {
Â  Â  Â  if (!this.isAlive) return;

Â  Â  Â  this.updateMovement(dt, this.speed);
Â  Â  Â  if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) return;

Â  Â  Â  const dx = target.x - this.x;
Â  Â  Â  const dy = target.y - this.y;
Â  Â  Â  const angle = Math.atan2(dy, dx);

Â  Â  Â  this.x += Math.cos(angle) * this.speed * dt;
Â  Â  Â  this.y += Math.sin(angle) * this.speed * dt;
Â  Â  }

Â  Â  draw(ctx, offset) {
Â  Â  Â  const screenPos = gameInstance.camera.worldToScreen(this.x, this.y);
Â  Â  Â  const halfW = this.width / 2;
Â  Â  Â  const halfH = this.height / 2;

Â  Â  Â  ctx.fillStyle = this.color;
Â  Â  Â  ctx.fillRect(screenPos.x - halfW, screenPos.y - halfH, this.width, this.height);
Â  Â  Â  ctx.strokeStyle = 'black';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  ctx.strokeRect(screenPos.x - halfW, screenPos.y - halfH, this.width, this.height);

Â  Â  Â  this.drawHealthBar(ctx, screenPos);
Â  Â  }
Â  }

Â  /** Boss æ•Œäºº (Wave ä¸»è¦ç›®æ ‡ä¹‹ä¸€) */
Â  class BossEnemy extends EnemyBase {
Â  Â  constructor(x, y) {
Â  Â  Â  super();
Â  Â  Â  this.x = x;
Â  Â  Â  this.y = y;
Â  Â  Â  this.radius = 70;
Â  Â  Â  // Boss è¡€é‡éš Wave æå‡
Â  Â  Â  this.maxHealth = 500 + gameInstance.wave * 200;
Â  Â  Â  this.health = this.maxHealth;
Â  Â  Â  this.speed = 50;
Â  Â  Â  this.damage = 25;
Â  Â  Â  this.expValue = 300;
Â  Â  Â  this.color = 'rgb(100, 50, 150)';
Â  Â  Â  this.attackCooldown = 5.0;
Â  Â  Â  this.lastAttackTime = 0;
Â  Â  Â  this.numProjectiles = 12;
Â  Â  }

Â  Â  takeDamage(damage) {
Â  Â  Â  this.health -= damage;
Â  Â  Â  if (this.health <= 0) {
Â  Â  Â  Â  this.isAlive = false;
Â  Â  Â  Â  gameInstance.player.gainExp(this.expValue);
Â  Â  Â  Â  gameInstance.player.score += this.expValue * 5;
Â  Â  Â  Â  // Boss æ­»äº¡ä¸è®¡å…¥ enemiesKilledThisWaveï¼Œä½†å…¶æ­»äº¡æ˜¯ Wave ç»“æŸçš„å¿…è¦æ¡ä»¶ã€‚
Â  Â  Â  Â  return true;
Â  Â  Â  }
Â  Â  Â  return false;
Â  Â  }

Â  Â  update(dt, currentTime, target) {
Â  Â  Â  if (!this.isAlive) return;

Â  Â  Â  this.updateMovement(dt, this.speed);
Â  Â  Â  if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) return;

Â  Â  Â  const dx = target.x - this.x;
Â  Â  Â  const dy = target.y - this.y;
Â  Â  Â  const angle = Math.atan2(dy, dx);

Â  Â  Â  this.x += Math.cos(angle) * this.speed * dt;
Â  Â  Â  this.y += Math.sin(angle) * this.speed * dt;

Â  Â  Â  if (currentTime >= this.lastAttackTime + this.attackCooldown) {
Â  Â  Â  Â  this.lastAttackTime = currentTime;
Â  Â  Â  Â  this.shootRadial();
Â  Â  Â  }
Â  Â  }

Â  Â  shootRadial() {
Â  Â  Â  const speed = 300;
Â  Â  Â  const damage = this.damage;
Â  Â  Â  const projectiles = [];

Â  Â  Â  for (let i = 0; i < this.numProjectiles; i++) {
Â  Â  Â  Â  const angle = (i / this.numProjectiles) * Math.PI * 2;
Â  Â  Â  Â  projectiles.push(new Projectile(this.x, this.y, angle, speed, damage, this, 'enemy'));
Â  Â  Â  }
Â  Â  Â  gameInstance.projectiles.push(...projectiles);
Â  Â  }

Â  Â  draw(ctx, offset) {
Â  Â  Â  const screenPos = gameInstance.camera.worldToScreen(this.x, this.y);

Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
Â  Â  Â  ctx.fillStyle = this.color;
Â  Â  Â  ctx.fill();
Â  Â  Â  ctx.strokeStyle = '#FFD700';
Â  Â  Â  ctx.lineWidth = 5;
Â  Â  Â  ctx.stroke();

Â  Â  Â  ctx.fillStyle = '#FFD700';
Â  Â  Â  const crownBaseY = screenPos.y - this.radius;

Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.moveTo(screenPos.x - this.radius * 0.5, crownBaseY);
Â  Â  Â  ctx.lineTo(screenPos.x + this.radius * 0.5, crownBaseY);

Â  Â  Â  for(let i = -2; i <= 2; i++) {
Â  Â  Â  Â  const tipX = screenPos.x + i * (this.radius * 0.2);
Â  Â  Â  Â  const tipY = crownBaseY - 20;
Â  Â  Â  Â  ctx.lineTo(tipX, tipY);
Â  Â  Â  Â  ctx.lineTo(tipX + (this.radius * 0.1), crownBaseY);
Â  Â  Â  }
Â  Â  Â  ctx.closePath();
Â  Â  Â  ctx.fill();

Â  Â  Â  this.drawHealthBar(ctx, screenPos);
Â  Â  }
Â  }

  /** æ–°å¢: éšå½¢è¿½è¸ªæ•Œäºº */
  class InvisibleEnemy extends EnemyBase {
    constructor(x, y) {
      super();
      this.x = x;
      this.y = y;
      this.radius = 28;
      this.maxHealth = 50;
      this.health = 50;
      this.baseSpeed = 150;
      this.revealedSpeed = 300;
      this.speed = this.baseSpeed;
      this.damage = 10;
      this.expValue = 25;
      
      this.isVisible = false;
      this.hasUsedShockwave = false;
      this.color = 'rgb(150, 0, 255)'; // ç´«è‰²

      this.attackCooldown = 2.5; // æ”»å‡»ç¨æ…¢
      this.lastAttackTime = 0;
      this.attackRange = 400;
    }

    takeDamage(damage) {
      this.health -= damage;
      
      if (!this.isVisible) {
        this.isVisible = true;
        this.speed = this.revealedSpeed; // æ˜¾å½¢ååŠ é€Ÿ
      }

      if (this.health <= 0) {
        this.isAlive = false;
        gameInstance.player.gainExp(this.expValue);
        gameInstance.player.score += this.expValue;
        gameInstance.enemiesKilledThisWave += 1; 
        return true;
      }
      return false;
    }

    update(dt, currentTime, target) {
      if (!this.isAlive) return;

      this.updateMovement(dt, this.speed);
      if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) return;

      const dx = target.x - this.x;
      const dy = target.y - this.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);

      // å§‹ç»ˆè¿½è¸ªç©å®¶
      this.x += Math.cos(angle) * this.speed * dt;
      this.y += Math.sin(angle) * this.speed * dt;

      // *** æ›´æ”¹ï¼šç°åœ¨éšå½¢æ—¶ä¹Ÿèƒ½æ”»å‡» ***
      if (distance < this.attackRange && currentTime >= this.lastAttackTime + this.attackCooldown) {
        this.lastAttackTime = currentTime;
        
        if (!this.hasUsedShockwave) {
          this.shootShockwave(target);
          this.hasUsedShockwave = true;
        } else {
          this.shoot(angle);
        }
      }
    }

    // ç¬¬ä¸€æ¬¡æ”»å‡»ï¼šå†²å‡»æ³¢ (å‡»é€€ç©å®¶)
    shootShockwave(target) {
      const dx = target.x - this.x;
      const dy = target.y - this.y;
      const angle = Math.atan2(dy, dx);
      const knockbackForce = 1200; // å¼ºåŠ›å‡»é€€
      gameInstance.player.applyKnockback(angle, knockbackForce);
      // å¯ä»¥åœ¨è¿™é‡ŒåŠ ä¸€ä¸ªè§†è§‰/å£°éŸ³æç¤º
    }

    // åç»­æ”»å‡»ï¼šæ™®é€šå°„å‡»
    shoot(angle) {
      const speed = 400;
      const damage = this.damage;
      const projectile = new Projectile(this.x, this.y, angle, speed, damage, this, 'enemy');
      gameInstance.projectiles.push(projectile);
    }

    draw(ctx, offset) {
      // ä¸å¯è§æ—¶å®Œå…¨ä¸ç»˜åˆ¶
      if (!this.isVisible) return; 

      const screenPos = gameInstance.camera.worldToScreen(this.x, this.y);

      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = this.color; // æ˜¾å½¢åä¸ºç´«è‰²
      ctx.globalAlpha = 0.8; // å¯ä»¥å¸¦ç‚¹åŠé€æ˜
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.stroke();

      this.drawHealthBar(ctx, screenPos);
    }
  }

  /** æ–°å¢: æ·±è“Boss */
  class DeepBlueBoss extends EnemyBase {
    constructor(x, y) {
      super();
      this.x = x;
      this.y = y;
      this.radius = 80; // æ›´å¤§
      this.maxHealth = 800 + gameInstance.wave * 250; // æ›´è‚‰
      this.health = this.maxHealth;
      this.speed = 40; // ç¨æ…¢
      this.damage = 20; // å†²å‡»æ³¢ä¼¤å®³
      this.expValue = 400;
      this.color = 'rgb(0, 50, 150)'; // æ·±è“è‰²

      this.shockwaveCooldown = 5.0; // 5ç§’CD
      this.lastShockwaveTime = 0;
      this.shockwaveRadius = 600; // èŒƒå›´å¤§

      // è§†è§‰æ•ˆæœ
      this.isShockwaving = false;
      this.shockwaveTimer = 0.0;
      this.shockwaveDuration = 0.3;
    }

    takeDamage(damage) {
      this.health -= damage;
      if (this.health <= 0) {
        this.isAlive = false;
        gameInstance.player.gainExp(this.expValue);
        gameInstance.player.score += this.expValue * 5;
        return true;
      }
      return false;
    }

    update(dt, currentTime, target) {
      if (!this.isAlive) return;

      this.updateMovement(dt, this.speed);
      if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) return;

      // æŒç»­è¿½è¸ª
      const dx = target.x - this.x;
      const dy = target.y - this.y;
      const angle = Math.atan2(dy, dx);
      this.x += Math.cos(angle) * this.speed * dt;
      this.y += Math.sin(angle) * this.speed * dt;

      // 5ç§’å†²å‡»æ³¢
      if (currentTime >= this.lastShockwaveTime + this.shockwaveCooldown) {
        this.lastShockwaveTime = currentTime;
        this.doShockwave(target);
      }

      // æ›´æ–°å†²å‡»æ³¢è§†è§‰
      if (this.isShockwaving) {
        this.shockwaveTimer -= dt;
        if (this.shockwaveTimer <= 0) {
          this.isShockwaving = false;
        }
      }
    }

    doShockwave(target) {
        this.isShockwaving = true;
        this.shockwaveTimer = this.shockwaveDuration;

        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨èŒƒå›´å†…
        if (distance < this.shockwaveRadius) {
            const angle = Math.atan2(dy, dx);
            // æ–½åŠ æ‰€æœ‰æ•ˆæœ
            target.takeDamage(this.damage);
            target.applyKnockback(angle, 1000); // 1000 å¼ºåŠ›å‡»é€€
            target.applySlow(2.0); // 2 ç§’å‡é€Ÿ
        }
    }

    draw(ctx, offset) {
      const screenPos = gameInstance.camera.worldToScreen(this.x, this.y);

      // ç»˜åˆ¶å†²å‡»æ³¢è§†è§‰
      if (this.isShockwaving) {
          const progress = 1 - (this.shockwaveTimer / this.shockwaveDuration);
          const currentRadius = progress * this.shockwaveRadius;
          const alpha = 0.5 - progress * 0.5;
          ctx.beginPath();
          ctx.arc(screenPos.x, screenPos.y, currentRadius, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`; // æµ…è“è‰²
          ctx.lineWidth = 15 + (1 - progress) * 20;
          ctx.stroke();
      }

      // ç»˜åˆ¶æœ¬ä½“
      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.strokeStyle = 'rgb(100, 200, 255)'; // æµ…è“è‰²æè¾¹
      ctx.lineWidth = 5;
      ctx.stroke();

      // ç»˜åˆ¶è¡€æ¡
      this.drawHealthBar(ctx, screenPos);
    }
  }


Â  // --------------------------------------------------------
Â  // 8. Game - æ¸¸æˆä¸»æ§åˆ¶å±‚ (Wave é€»è¾‘æ ¸å¿ƒ)
Â  // --------------------------------------------------------

Â  let gameInstance;

Â  class Game {
Â  Â  constructor() {
Â  Â  Â  this.canvas = document.getElementById('gameCanvas');
Â  Â  Â  this.ctx = this.canvas.getContext('2d');
Â  Â  Â  this.musicControl = document.getElementById('music-control');
Â  Â  Â  this.bgm = document.getElementById('backgroundMusic');

Â  Â  Â  this.data = new PlayerData();
Â  Â  Â  this.camera = new Camera(CANVAS_WIDTH, CANVAS_HEIGHT);
      this.resizeCanvas(); // ç«‹å³è®¾ç½®ç”»å¸ƒå¤§å°
Â  Â  Â  this.world = new InfiniteWorld();

Â  Â  Â  this.state = GameState.MENU;
      this.setState(GameState.MENU); // è®¾ç½®åˆå§‹çŠ¶æ€
Â  Â  Â  this.running = true;

Â  Â  Â  this.player = null;
Â  Â  Â  this.enemies = [];
Â  Â  Â  this.projectiles = [];
Â  Â  Â  this.buildings = [];

Â  Â  Â  this.lastTime = 0;
Â  Â  Â  this.currentTime = 0;

Â  Â  Â  // --- Wave æ ¸å¿ƒå±æ€§ ---
Â  Â  Â  this.wave = 1;
Â  Â  Â  this.enemiesKilledThisWave = 0;
Â  Â  Â  this.enemiesSpawnedThisWave = 0; // æ–°å¢: æœ¬æ³¢å·²ç”Ÿæˆçš„æ•Œäººæ•°é‡
Â  Â  Â  this.enemiesToKillForNextWave = 100; // Wave 1 ç›®æ ‡
Â  Â  Â  this.isWaveTransition = false; // Wave è½¬æ¢æœŸé—´çš„æš‚åœå’Œæç¤º
Â  Â  Â  this.waveTransitionTimer = 0.0;
Â  Â  Â  this.baseMaxEnemies = 40; // åŸºç¡€æœ€å¤§æ•Œäººæ•°é‡ (å±å¹•ä¸Šçš„è½¯ä¸Šé™)
Â  Â  Â  this.enemySpawnTimer = 0; // æŒç»­ç”Ÿæˆè®¡æ—¶å™¨

Â  Â  Â  this.input = {
Â  Â  Â  Â  keys: {},
Â  Â  Â  Â  mouse: { x: 0, y: 0, worldX: 0, worldY: 0, leftClick: false }
Â  Â  Â  };

      // èœå• UI ç‚¹å‡»åŒºåŸŸ
      this.startButtonRect = null;
      this.skinChangeLeftRect = null;
      this.skinChangeRightRect = null;

Â  Â  Â  this.setupEventListeners();
Â  Â  Â  this.updateMusicControlUI();
Â  Â  Â  this.run();
Â  Â  }

    resizeCanvas() {
        CANVAS_WIDTH = window.innerWidth;
        CANVAS_HEIGHT = window.innerHeight;
        
        this.canvas.width = CANVAS_WIDTH;
        this.canvas.height = CANVAS_HEIGHT;
        
        if (this.camera) {
            this.camera.width = CANVAS_WIDTH;
            this.camera.height = CANVAS_HEIGHT;
        }
    }

Â  Â  setState(newState) {
Â  Â  Â  this.state = newState;
Â  Â  Â  if (newState === GameState.GAME) {
Â  Â  Â  Â  this.lastTime = performance.now();
        this.canvas.style.cursor = "crosshair"; // æ¸¸æˆæ—¶ä¸ºå‡†æ˜Ÿ
Â  Â  Â  Â  // å°è¯•åœ¨æ¸¸æˆå¼€å§‹æ—¶æ’­æ”¾éŸ³ä¹ (ç»•è¿‡æµè§ˆå™¨é™åˆ¶)
Â  Â  Â  Â  this.bgm.play().catch(e => console.log("Music autoplay failed, user needs interaction."));
Â  Â  Â  } else if (newState === GameState.MENU) {
        this.canvas.style.cursor = "default"; // èœå•æ—¶ä¸ºé»˜è®¤
      }
Â  Â  }

Â  Â  toggleMusic() {
Â  Â  Â  if (this.bgm.paused) {
Â  Â  Â  Â  this.bgm.play().catch(e => console.error("æ— æ³•æ’­æ”¾éŸ³ä¹:", e));
Â  Â  Â  } else {
Â  Â  Â  Â  this.bgm.pause();
Â  Â  Â  }
Â  Â  Â  this.updateMusicControlUI();
Â  Â  }

Â  Â  updateMusicControlUI() {
Â  Â  Â  if (this.bgm.paused) {
Â  Â  Â  Â  this.musicControl.textContent = 'ğŸ”‡ éŸ³ä¹: å…³é—­';
Â  Â  Â  Â  this.musicControl.style.backgroundColor = 'rgba(255, 50, 50, 0.9)';
Â  Â  Â  } else {
Â  Â  Â  Â  this.musicControl.textContent = 'ğŸ”Š éŸ³ä¹: å¼€å¯';
Â  Â  Â  Â  this.musicControl.style.backgroundColor = 'rgba(255, 215, 0, 0.9)';
Â  Â  Â  }
Â  Â  }

Â  Â  setupEventListeners() {
      // çª—å£å¤§å°æ”¹å˜
      window.addEventListener('resize', () => this.resizeCanvas());

Â  Â  Â  document.addEventListener('keydown', (e) => {
Â  Â  Â  Â  const key = e.key.toLowerCase();
Â  Â  Â  Â  this.input.keys[key] = true;
Â  Â  Â  Â  this.handleGameStateInput(key);
Â  Â  Â  });

Â  Â  Â  document.addEventListener('keyup', (e) => {
Â  Â  Â  Â  const key = e.key.toLowerCase();
Â  Â  Â  Â  this.input.keys[key] = false;
Â  Â  Â  });

Â  Â  Â  this.canvas.addEventListener('mousedown', (e) => {
Â  Â  Â  Â  if (e.button === 0) {
          if (this.state === GameState.GAME) {
            this.input.mouse.leftClick = true;
          }
Â  Â  Â  Â  Â  if (this.state === GameState.MENU || this.state === GameState.GAME_OVER) {
Â  Â  Â  Â  Â  Â  this.handleMenuClick(this.input.mouse.x, this.input.mouse.y);
Â  Â  Â  Â  Â  }
        }
Â  Â  Â  });

Â  Â  Â  this.canvas.addEventListener('mouseup', (e) => {
Â  Â  Â  Â  if (e.button === 0) this.input.mouse.leftClick = false;
Â  Â  Â  });

Â  Â  Â  this.canvas.addEventListener('mousemove', (e) => {
Â  Â  Â  Â  const rect = this.canvas.getBoundingClientRect();
Â  Â  Â  Â  this.input.mouse.x = e.clientX - rect.left;
Â  Â  Â  Â  this.input.mouse.y = e.clientY - rect.top;

Â  Â  Â  Â  if (this.camera) {
Â  Â  Â  Â  Â  this.input.mouse.worldX = this.input.mouse.x + this.camera.x;
Â  Â  Â  Â  Â  this.input.mouse.worldY = this.input.mouse.y + this.camera.y;
Â  Â  Â  Â  }

        // é¼ æ ‡æ‚¬åœåœ¨èœå•æŒ‰é’®ä¸Šæ—¶æ”¹å˜å…‰æ ‡
        if (this.state === GameState.MENU) {
          const checkHit = (rect) => {
            if (!rect) return false;
            return this.input.mouse.x > rect.x && this.input.mouse.x < rect.x + rect.w &&
                   this.input.mouse.y > rect.y && this.input.mouse.y < rect.y + rect.h;
          };
          if (checkHit(this.startButtonRect) || checkHit(this.skinChangeLeftRect) || checkHit(this.skinChangeRightRect)) {
            this.canvas.style.cursor = "pointer";
          } else {
            this.canvas.style.cursor = "default";
          }
        } else if (this.state === GameState.GAME) {
          this.canvas.style.cursor = "crosshair";
        }

Â  Â  Â  });

Â  Â  Â  // éŸ³ä¹æ§åˆ¶æŒ‰é’®äº‹ä»¶
Â  Â  Â  this.musicControl.addEventListener('click', () => this.toggleMusic());
Â  Â  }

Â  Â  handleGameStateInput(key) {
Â  Â  Â  if (this.state === GameState.GAME_OVER) {
Â  Â  Â  Â  if (key === 'r') this.newGame();
Â  Â  Â  Â  if (key === 'escape') this.setState(GameState.MENU);
Â  Â  Â  } else if (this.state === GameState.LEVEL_UP) {
Â  Â  Â  Â  if (key === '1' || key === '2' || key === '3') {
Â  Â  Â  Â  Â  let upgradeType;
Â  Â  Â  Â  Â  if (key === '1') upgradeType = 'damage';
Â  Â  Â  Â  Â  else if (key === '2') upgradeType = 'health';
Â  Â  Â  Â  Â  else if (key === '3') upgradeType = 'speed';

Â  Â  Â  Â  Â  this.player.applyUpgrade(upgradeType);
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }

    changeSkin(direction) {
        const skins = this.data.ownedSkins;
        let currentIndex = skins.indexOf(this.data.currentSkin);
        currentIndex += direction;
        
        if (currentIndex < 0) {
            currentIndex = skins.length - 1;
        } else if (currentIndex >= skins.length) {
            currentIndex = 0;
        }
        
        this.data.currentSkin = skins[currentIndex];
        this.data.saveData();
    }

Â  Â  handleMenuClick(mouseX, mouseY) {
      const checkHit = (rect) => {
          if (!rect) return false;
          return mouseX > rect.x && mouseX < rect.x + rect.w &&
                 mouseY > rect.y && mouseY < rect.y + rect.h;
      };

Â  Â  Â  if (this.state === GameState.MENU) {
Â  Â  Â  Â  if (checkHit(this.startButtonRect)) {
Â  Â  Â  Â  Â  this.newGame();
Â  Â  Â  Â  } else if (checkHit(this.skinChangeLeftRect)) {
            this.changeSkin(-1);
        } else if (checkHit(this.skinChangeRightRect)) {
            this.changeSkin(1);
        }
Â  Â  Â  }
Â  Â  }

Â  Â  newGame() {
Â  Â  Â  this.player = new Player(0, 0, this.data);
Â  Â  Â  this.enemies = [];
Â  Â  Â  this.projectiles = [];
Â  Â  Â  this.buildings = [];
Â  Â  Â  this.player.score = 0;

Â  Â  Â  // é‡ç½® Wave çŠ¶æ€
Â  Â  Â  this.wave = 1;
Â  Â  Â  this.enemiesKilledThisWave = 0;
Â  Â  Â  this.enemiesSpawnedThisWave = 0;
Â  Â  Â  this.isWaveTransition = false;
Â  Â  Â  this.waveTransitionTimer = 0.0;
Â  Â  Â  this.world.chunks.clear();

Â  Â  Â  this.startNextWave(true); // å¯åŠ¨ Wave 1
Â  Â  Â  this.setState(GameState.GAME);
Â  Â  }

Â  Â  startNextWave(isInitial = false) {
Â  Â  Â  if (!isInitial) {
Â  Â  Â  Â  this.wave += 1;
Â  Â  Â  }

Â  Â  Â  // --- Wave ç›®æ ‡è®¡ç®— ---
Â  Â  Â  // Wave 1: 100, Wave 2: 150, Wave 3: 200, ...
Â  Â  Â  this.enemiesToKillForNextWave = 100 + (this.wave - 1) * 50;
Â  Â  Â  this.enemiesKilledThisWave = 0;
Â  Â  Â  this.enemiesSpawnedThisWave = 0;

Â  Â  Â  // Wave è½¬æ¢æç¤º
Â  Â  Â  this.isWaveTransition = true;
Â  Â  Â  this.waveTransitionTimer = 3.0; // 3ç§’è¿‡æ¸¡æ—¶é—´

Â  Â  Â  // 1. ç«‹å³ç”Ÿæˆå¯†é›†æ™®é€šæ•Œäºº (è¾¾æˆç›®æ ‡çš„ç¬¬ä¸€éƒ¨åˆ†)
Â  Â  Â  this.spawnWaveInitialEnemies(this.enemiesToKillForNextWave + 20); // PCç‰ˆä¹Ÿå¢åŠ 20ä¸ª

Â  Â  Â  // 2. åªæœ‰ Wave 2 åŠä»¥åæ‰ç”Ÿæˆ Boss
Â  Â  Â  if (this.wave >= 2) {
Â  Â  Â  Â  this.spawnWaveBosses(this.wave); // ç”Ÿæˆ X ä¸ª Boss
Â  Â  Â  }
Â  Â  }

Â  Â  /**
Â  Â  Â * åœ¨ Wave å¼€å§‹æ—¶ï¼Œåœ¨ç©å®¶å‘¨å›´ä¸€å®šèŒƒå›´å†…å¯†é›†ç”Ÿæˆæ‰€æœ‰æ™®é€šæ•Œäººç›®æ ‡ã€‚
Â  Â  Â * @param {number} count è¦ç”Ÿæˆçš„æ•Œäººæ€»æ•°
Â  Â  Â */
Â  Â  spawnWaveInitialEnemies(count) {
Â  Â  Â  const rng = new SeededRNG(performance.now());
Â  Â  Â  const spawnRadiusMin = 300; // é¿å…å‡ºç”Ÿç‚¹é‡å 
Â  Â  Â  const spawnRadiusMax = 1500; // åˆå§‹æ•£å¸ƒèŒƒå›´

Â  Â  Â  for (let i = 0; i < count; i++) {
Â  Â  Â  Â  const angle = rng.randFloat(0, Math.PI * 2);
Â  Â  Â  Â  const distance = rng.randFloat(spawnRadiusMin, spawnRadiusMax);

Â  Â  Â  Â  const spawnX = this.player.x + Math.cos(angle) * distance;
Â  Â  Â  Â  const spawnY = this.player.y + Math.sin(angle) * distance;

Â  Â  Â  Â  let enemy;
Â  Â  Â  Â  // æ•Œäººç±»åˆ·æ–°æƒé‡: 10% éšå½¢, 75% å°„æ‰‹, 25% è¿‘æˆ˜ (æ€»å’Œ 110)
        const choice = rng.randFloat(0, 110);

        if (choice < 10) { // 10% éšå½¢
          enemy = new InvisibleEnemy(spawnX, spawnY);
        } else if (choice < 85) { // 75% å°„æ‰‹ (10 + 75)
          enemy = new NormalShooter(spawnX, spawnY);
        } else { // 25% è¿‘æˆ˜
          enemy = new FastMeleeEnemy(spawnX, spawnY);
        }

Â  Â  Â  Â  this.enemies.push(enemy);
Â  Â  Â  Â  this.enemiesSpawnedThisWave += 1;
Â  Â  Â  }
Â  Â  }

Â  Â  spawnWaveBosses(numBosses) {
Â  Â  Â  const rng = new SeededRNG(performance.now() + 1); // Use slightly different seed
Â  Â  Â  const spawnDistance = 2000; // ç¡®ä¿ Boss è¶³å¤Ÿè¿œ

Â  Â  Â  for (let i = 0; i < numBosses; i++) {
Â  Â  Â  Â  const angle = rng.randFloat(0, Math.PI * 2);

Â  Â  Â  Â  const spawnX = this.player.x + Math.cos(angle) * spawnDistance;
Â  Â  Â  Â  const spawnY = this.player.y + Math.sin(angle) * spawnDistance;

Â  Â  Â  Â  let boss;
        // *** æ›´æ”¹ï¼šäº¤æ›¿ç”ŸæˆBoss ***
        if (this.wave % 2 === 0) { // å¶æ•°æ³¢ (2, 4, 6...)
            boss = new BossEnemy(spawnX, spawnY); // åŸç‰ˆç´«è‰²Boss
        } else { // å¥‡æ•°æ³¢ (3, 5, 7...)
            boss = new DeepBlueBoss(spawnX, spawnY); // æ–°ç‰ˆè“è‰²Boss
        }
Â  Â  Â  Â  this.enemies.push(boss);
Â  Â  Â  }
Â  Â  }

Â  Â  update(dt) {
Â  Â  Â  this.currentTime = performance.now() / 1000.0;

Â  Â  Â  if (this.state !== GameState.GAME) return;

Â  Â  Â  // 1. Wave è½¬æ¢è®¡æ—¶å™¨ (æš‚åœæ¸¸æˆé€»è¾‘)
Â  Â  Â  if (this.isWaveTransition) {
Â  Â  Â  Â  this.waveTransitionTimer -= dt;
Â  Â  Â  Â  if (this.waveTransitionTimer <= 0) {
Â  Â  Â  Â  Â  this.isWaveTransition = false;
Â  Â  Â  Â  }
Â  Â  Â  Â  // è½¬æ¢æœŸé—´åªå…è®¸ç©å®¶ç§»åŠ¨å’Œé‡Šæ”¾æŠ€èƒ½ (åŒ…æ‹¬æ›´æ–°å†·å´)
Â  Â  Â  Â  this.player.handleInput(this.input, dt);
Â  Â  Â  Â  this.player.update(dt);
Â  Â  Â  Â  this.camera.update(this.player, dt);
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  // 2. Wave æ¨è¿›æ£€æŸ¥
      // *** æ›´æ”¹ï¼šç°åœ¨æ£€æŸ¥æ‰€æœ‰Bossç±»å‹ ***
Â  Â  Â  const activeBosses = this.enemies.filter(e => e instanceof BossEnemy || e instanceof DeepBlueBoss).length;
Â  Â  Â  if (this.enemiesKilledThisWave >= this.enemiesToKillForNextWave && activeBosses === 0) {
Â  Â  Â  Â  this.startNextWave();
Â  Â  Â  }

Â  Â  Â  // 3. ç©å®¶æ›´æ–°
Â  Â  Â  this.player.handleInput(this.input, dt);
Â  Â  Â  this.player.update(dt);

Â  Â  Â  // 4. ä¸–ç•Œå’Œå»ºç­‘åŠ è½½
Â  Â  Â  const worldContent = this.world.getVisibleContent(this.player);
Â  Â  Â  this.buildings = worldContent.buildings;

Â  Â  Â  // 5. æ•ŒäººæŒç»­ç”Ÿæˆ (è½¯ä¸Šé™æ§åˆ¶)
Â  Â  Â  this.enemySpawnTimer += dt;

Â  Â  Â  // éš¾åº¦ç¼©æ”¾: Wave è¶Šé«˜ï¼Œæœ€å¤§æ•Œäººæ•°é‡è¶Šå¤šï¼Œç”Ÿæˆè¶Šå¿«
Â  Â  Â  const maxEnemyScale = 1 + this.wave * 0.15;
Â  Â  Â  const currentMaxEnemies = Math.min(250, Math.floor(this.baseMaxEnemies * maxEnemyScale));
Â  Â  Â  const continuousSpawnRate = 0.5; // æŒç»­ç”Ÿæˆé—´éš” (ç§’)

      // *** æ›´æ”¹ï¼šæ£€æŸ¥æ‰€æœ‰Bossç±»å‹ ***
Â  Â  Â  const currentNormalEnemies = this.enemies.filter(e => !(e instanceof BossEnemy || e instanceof DeepBlueBoss)).length;

Â  Â  Â  // åªæœ‰å½“åœºä¸Šæ™®é€šæ•Œäººæ•°é‡ä½äºè½¯ä¸Šé™ï¼Œä¸”å·²ç”Ÿæˆçš„æ•Œäººæ€»æ•°æœªè¾¾åˆ°æœ¬æ³¢ç›®æ ‡æ—¶ï¼Œæ‰æŒç»­ç”Ÿæˆ
Â  Â  Â  if (currentNormalEnemies < currentMaxEnemies && this.enemiesSpawnedThisWave < this.enemiesToKillForNextWave && this.enemySpawnTimer > continuousSpawnRate) {
Â  Â  Â  Â  this.spawnSingleEnemy(worldContent.chunkKeys);
Â  Â  Â  Â  this.enemiesSpawnedThisWave += 1;
Â  Â  Â  Â  this.enemySpawnTimer = 0;
Â  Â  Â  }

Â  Â  Â  // 6. å®ä½“å’ŒæŠ•å°„ç‰©æ›´æ–°
Â  Â  Â  this.enemies.forEach(e => e.update(dt, this.currentTime, this.player));
Â  Â  Â  this.projectiles.forEach(p => p.update(dt));

Â  Â  Â  // 7. æˆ˜æ–—å’Œç¢°æ’æ£€æµ‹
Â  Â  Â  this.handleCollisions(dt);

Â  Â  Â  // 8. è¿‡æ»¤å·²æ­»äº¡/è¶…æ—¶çš„å®ä½“
Â  Â  Â  this.projectiles = this.projectiles.filter(p => p.isAlive);
Â  Â  Â  this.enemies = this.enemies.filter(e => e.isAlive);
Â  Â  Â  this.buildings = this.buildings.filter(b => b.isAlive);

Â  Â  Â  // 9. ç©å®¶æ”»å‡»
Â  Â  Â  if (this.input.mouse.leftClick) {
Â  Â  Â  Â  const newProjectile = this.player.attack(this.currentTime, this.input.mouse.worldX, this.input.mouse.worldY);
Â  Â  Â  Â  if (newProjectile) {
Â  Â  Â  Â  Â  this.projectiles.push(newProjectile);
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  // 10. æ‘„åƒæœºè·Ÿéš
Â  Â  Â  this.camera.update(this.player, dt);

Â  Â  Â  // 11. æ­»äº¡æ£€æŸ¥
Â  Â  Â  if (!this.player.isAlive) {
Â  Â  Â  Â  this.data.updateHighScore(Math.floor(this.player.score));
Â  Â  Â  Â  const coinsGained = Math.floor(this.player.score / 2000);
Â  Â  Â  Â  this.data.addCoins(coinsGained);
Â  Â  Â  Â  this.setState(GameState.GAME_OVER);
Â  Â  Â  }
Â  Â  }

Â  Â  /**
Â  Â  Â * åœ¨å¯è§åŒºåŸŸå¤–éšæœºç”Ÿæˆå•ä¸ªæ•Œäºº (ç”¨äºæŒç»­è¡¥å……)
Â  Â  Â */
Â  Â  spawnSingleEnemy(chunkKeys) {
Â  Â  Â  if (chunkKeys.length === 0) return;

Â  Â  Â  const rng = new SeededRNG(performance.now() + 2); // Use slightly different seed
Â  Â  Â  const targetChunkCoords = rng.choice(chunkKeys);
Â  Â  Â  const bounds = this.world.getChunkWorldBounds(targetChunkCoords.x, targetChunkCoords.y);

Â  Â  Â  let spawnX = rng.randFloat(bounds.x, bounds.x + bounds.width);
Â  Â  Â  let spawnY = rng.randFloat(bounds.y, bounds.y + bounds.height);

      // ä½¿ç”¨åŠ¨æ€å®½é«˜
Â  Â  Â  const screenDist = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) / 2 + 100;
Â  Â  Â  const distToPlayer = Math.sqrt((spawnX - this.player.x) ** 2 + (spawnY - this.player.y) ** 2);

Â  Â  Â  // ç¡®ä¿ç”Ÿæˆåœ¨å±å¹•å¤–
Â  Â  Â  if (distToPlayer < screenDist) {
Â  Â  Â  Â  const angle = Math.atan2(spawnY - this.player.y, spawnX - this.player.x);
Â  Â  Â  Â  spawnX = this.player.x + Math.cos(angle) * screenDist;
Â  Â  Â  Â  spawnY = this.player.y + Math.sin(angle) * screenDist;
Â  Â  Â  }

Â  Â  Â  let enemy;
Â  Â  Â  // æ•Œäººç±»åˆ·æ–°æƒé‡: 10% éšå½¢, 75% å°„æ‰‹, 25% è¿‘æˆ˜ (æ€»å’Œ 110)
      const choice = rng.randFloat(0, 110);

      if (choice < 10) { // 10% éšå½¢
        enemy = new InvisibleEnemy(spawnX, spawnY);
      } else if (choice < 85) { // 75% å°„æ‰‹ (10 + 75)
        enemy = new NormalShooter(spawnX, spawnY);
      } else { // 25% è¿‘æˆ˜
        enemy = new FastMeleeEnemy(spawnX, spawnY);
      }

Â  Â  Â  this.enemies.push(enemy);
Â  Â  }

Â  Â  handleCollisions(dt) {
Â  Â  Â  // --- E é”®å†²å‡»æ³¢æ•ˆæœ ---
Â  Â  Â  if (this.player.isShockwaving && this.player.shockwaveTimer >= this.player.shockwaveDuration - dt) {
Â  Â  Â  Â  const shockwaveDamage = this.player.shockwaveDamage * this.player.damageMultiplier;
Â  Â  Â  Â  const knockbackForce = 1500;

Â  Â  Â  Â  this.enemies.forEach(e => {
Â  Â  Â  Â  Â  if (e.isAlive) {
Â  Â  Â  Â  Â  Â  const dx = e.x - this.player.x;
Â  Â  Â  Â  Â  Â  const dy = e.y - this.player.y;
Â  Â  Â  Â  Â  Â  const distance = Math.sqrt(dx * dx + dy * dy);

Â  Â  Â  Â  Â  Â  if (distance < this.player.shockwaveRadius) {
Â  Â  Â  Â  Â  Â  Â  e.takeDamage(shockwaveDamage);
Â  Â  Â  Â  Â  Â  Â  const angle = Math.atan2(dy, dx);
Â  Â  Â  Â  Â  Â  Â  e.applyKnockback(angle, knockbackForce);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  }

Â  Â  Â  // --- ç©å®¶ vs å»ºç­‘ ---
Â  Â  Â  this.buildings.forEach(b => {
Â  Â  Â  Â  CollisionManager.checkAndResolve(this.player, b);
Â  Â  Â  });

Â  Â  Â  // --- æŠ•å°„ç‰© vs å®ä½“/å»ºç­‘ ---
Â  Â  Â  this.projectiles.forEach(p => {
Â  Â  Â  Â  if (!p.isAlive) return;

Â  Â  Â  Â  if (p.type === 'player') {
Â  Â  Â  Â  Â  this.enemies.forEach(e => {
Â  Â  Â  Â  Â  Â  if (e.isAlive && CollisionManager.checkCircleCollision(p, e)) {
Â  Â  Â  Â  Â  Â  Â  e.takeDamage(p.damage); // takeDamage ä¼šå¤„ç†éšå½¢æ•Œäººçš„æ˜¾å½¢
Â  Â  Â  Â  Â  Â  Â  p.isAlive = false;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  this.buildings.forEach(b => {
Â  Â  Â  Â  Â  Â  if (b.isDestroyable && p.x > b.x && p.x < b.x + b.width && p.y > b.y && p.y < b.y + b.height) {
Â  Â  Â  Â  Â  Â  Â  b.takeDamage(p.damage);
Â  Â  Â  Â  Â  Â  Â  p.isAlive = false;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  });

Â  Â  Â  Â  } else if (p.type === 'enemy') {
Â  Â  Â  Â  Â  if (this.player.isAlive && CollisionManager.checkCircleCollision(p, this.player)) {
Â  Â  Â  Â  Â  Â  this.player.takeDamage(p.damage);
Â  Â  Â  Â  Â  Â  p.isAlive = false;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  });

Â  Â  Â  // --- æ•Œäºº vs ç©å®¶ (æ¥è§¦ä¼¤å®³) ---
Â  Â  Â  this.enemies.forEach(e => {
Â  Â  Â  Â  if (e.isAlive && CollisionManager.checkCircleCollision(e, this.player)) {
Â  Â  Â  Â  Â  if (e instanceof FastMeleeEnemy) {
Â  Â  Â  Â  Â  Â  this.player.takeDamage(e.damage * dt * 5);
Â  Â  Â  Â  Â  } else if (e instanceof InvisibleEnemy || e instanceof DeepBlueBoss) {
            // éšå½¢æ•Œäººå’Œæ–°Bossä¸é€ æˆæ¥è§¦ä¼¤å®³
          } else {
Â  Â  Â  Â  Â  Â  this.player.takeDamage(e.damage * dt);
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  }

Â  Â  // --- ç”»é¢æ¸²æŸ“ ---

Â  Â  draw() {
Â  Â  Â  this.ctx.fillStyle = BACKGROUND_COLOR;
Â  Â  Â  this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

Â  Â  Â  const offset = { x: this.camera.x, y: this.camera.y };

Â  Â  Â  this.drawGrid();

Â  Â  Â  if (this.state === GameState.GAME || this.state === GameState.LEVEL_UP || this.state === GameState.GAME_OVER) {
Â  Â  Â  Â  const viewport = this.camera.getViewport();
Â  Â  Â  Â  const inView = (entity) => entity.x > viewport.left && entity.x < viewport.right && entity.y > viewport.top && entity.y < viewport.bottom;

Â  Â  Â  Â  this.buildings.filter(inView).forEach(b => b.draw(this.ctx, offset));
Â  Â  Â  Â  this.projectiles.filter(inView).forEach(p => p.draw(this.ctx, offset));
Â  Â  Â  Â  this.enemies.filter(inView).forEach(e => e.draw(this.ctx, offset));

        if(this.player) {
Â  Â  Â  Â    this.player.draw(this.ctx, offset);
        }

Â  Â  Â  Â  this.drawHUD();
Â  Â  Â  }

Â  Â  Â  if (this.state === GameState.MENU) this.drawMenu();
Â  Â  Â  else if (this.state === GameState.LEVEL_UP) this.drawLevelUpScreen();
Â  Â  Â  else if (this.state === GameState.GAME_OVER) this.drawGameOverScreen();

Â  Â  Â  // ç»˜åˆ¶ Wave è½¬æ¢æç¤º
Â  Â  Â  if (this.isWaveTransition) this.drawWaveTransition();
Â  Â  }

Â  Â  drawGrid() {
Â  Â  Â  this.ctx.strokeStyle = GRID_COLOR;
Â  Â  Â  this.ctx.lineWidth = 1;
Â  Â  Â  const step = 50;

Â  Â  Â  const startX = -this.camera.x % step;
Â  Â  Â  const startY = -this.camera.y % step;

Â  Â  Â  for (let x = startX; x < CANVAS_WIDTH; x += step) {
Â  Â  Â  Â  this.ctx.beginPath();
Â  Â  Â  Â  this.ctx.moveTo(x, 0);
Â  Â  Â  Â  this.ctx.lineTo(x, CANVAS_HEIGHT);
Â  Â  Â  Â  this.ctx.stroke();
Â  Â  Â  }

Â  Â  Â  for (let y = startY; y < CANVAS_HEIGHT; y += step) {
Â  Â  Â  Â  this.ctx.beginPath();
Â  Â  Â  Â  this.ctx.moveTo(0, y);
Â  Â  Â  Â  this.ctx.lineTo(CANVAS_WIDTH, y);
Â  Â  Â  Â  this.ctx.stroke();
Â  Â  Â  }
Â  Â  }

Â  Â  drawText(text, x, y, size, color = 'white', font = 'Arial', align = 'left') {
Â  Â  Â  this.ctx.font = `${size}px ${font}`;
Â  Â  Â  this.ctx.fillStyle = color;
Â  Â  Â  this.ctx.textAlign = align;
Â  Â  Â  this.ctx.fillText(text, x, y);
Â  Â  }

Â  Â  drawWaveTransition() {
Â  Â  Â  const centerX = CANVAS_WIDTH / 2;
Â  Â  Â  const centerY = CANVAS_HEIGHT / 2;

Â  Â  Â  // æ¸å˜é€æ˜çš„èƒŒæ™¯é®ç½©
Â  Â  Â  const alpha = Math.min(0.8, Math.abs(this.waveTransitionTimer - 1.5) / 1.5);
Â  Â  Â  this.ctx.fillStyle = `rgba(10, 10, 30, ${alpha})`;
Â  Â  Â  this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

Â  Â  Â  // æ–‡æœ¬é—ªçƒæ•ˆæœ
Â  Â  Â  const flash = Math.abs(Math.sin(this.currentTime * 5));
      const baseSize = Math.min(CANVAS_WIDTH * 0.1, 120); // å“åº”å¼å­—ä½“

Â  Â  Â  this.drawText(`WAVE ${this.wave}`, centerX, centerY - 30, baseSize, '#FFD700', 'Impact', 'center');

Â  Â  Â  if (this.wave >= 2) {
        const bossName = (this.wave % 2 === 0) ? "Boss" : "æ·±è“ä¸»å®°";
Â  Â  Â  Â  this.drawText(`ç”Ÿæˆ ${bossName}!`, centerX, centerY + 30, baseSize * 0.4, `rgba(255, 50, 50, ${flash})`, 'Arial', 'center');
Â  Â  Â  } else {
Â  Â  Â  Â  this.drawText(`æ•Œäººæ­£åœ¨é è¿‘!`, centerX, centerY + 30, baseSize * 0.4, `rgba(0, 255, 0, ${flash})`, 'Arial', 'center');
Â  Â  Â  }
Â  Â  }

Â  Â  drawMenu() {
Â  Â  Â  const centerX = CANVAS_WIDTH / 2;
      const baseSize = Math.min(CANVAS_WIDTH * 0.1, 90); // å“åº”å¼å­—ä½“

Â  Â  Â  this.drawText("DANTAO", centerX, CANVAS_HEIGHT * 0.2, baseSize, '#FFD700', 'Impact', 'center');
      this.drawText("æ— å°½ Wave ç”Ÿå­˜æ¨¡å¼", centerX, CANVAS_HEIGHT * 0.2 + baseSize * 0.6, baseSize * 0.4, 'white', 'Arial', 'center');


Â  Â  Â  // --- å¼€å§‹æŒ‰é’® ---
Â  Â  Â  const btnW = Math.min(CANVAS_WIDTH * 0.4, 300);
      const btnH = Math.min(CANVAS_HEIGHT * 0.08, 60);
      const btnX = centerX - btnW / 2;
      const btnY = CANVAS_HEIGHT * 0.45;
Â  Â  Â  this.ctx.fillStyle = '#4650a3';
Â  Â  Â  this.ctx.fillRect(btnX, btnY, btnW, btnH);
Â  Â  Â  this.ctx.strokeStyle = 'white';
Â  Â  Â  this.ctx.lineWidth = 3;
Â  Â  Â  this.ctx.strokeRect(btnX, btnY, btnW, btnH);
Â  Â  Â  this.drawText("å¼€å§‹æ¸¸æˆ", centerX, btnY + btnH * 0.7, btnH * 0.5, 'white', 'Arial', 'center');
      this.startButtonRect = { x: btnX, y: btnY, w: btnW, h: btnH }; // å­˜å‚¨çŸ©å½¢

      // --- çš®è‚¤é€‰æ‹© UI ---
      const skinY = CANVAS_HEIGHT * 0.65;
      const skinText = `çš®è‚¤: ${this.data.currentSkin.toUpperCase()}`;
      const skinTextSize = Math.min(CANVAS_WIDTH * 0.03, 30);
      this.drawText(skinText, centerX, skinY, skinTextSize, 'white', 'Arial', 'center');
      
      this.ctx.font = `${skinTextSize}px Arial`;
      const textWidth = this.ctx.measureText(skinText).width;
      const arrowSize = skinTextSize * 1.3;
      const arrowY = skinY - (arrowSize * 0.3); // å‚ç›´å¯¹é½

      // å·¦ç®­å¤´
      const leftArrowX = centerX - textWidth / 2 - 50;
      this.drawText("<", leftArrowX, arrowY + 10, arrowSize, '#FFD700', 'Impact', 'center');
      this.skinChangeLeftRect = { x: leftArrowX - arrowSize/2, y: arrowY - arrowSize/2, w: arrowSize, h: arrowSize };
      
      // å³ç®­å¤´
      const rightArrowX = centerX + textWidth / 2 + 50;
      this.drawText(">", rightArrowX, arrowY + 10, arrowSize, '#FFD700', 'Impact', 'center');
      this.skinChangeRightRect = { x: rightArrowX - arrowSize/2, y: arrowY - arrowSize/2, w: arrowSize, h: arrowSize };


Â  Â  Â  const bottomY = CANVAS_HEIGHT - 30;
      const smallFontSize = Math.min(CANVAS_WIDTH * 0.02, 24);
      this.drawText(`æœ€é«˜åˆ†: ${this.data.highScore}`, 30, bottomY, smallFontSize, 'white');
Â  Â  Â  this.drawText(`é‡‘å¸: ${this.data.coins}`, centerX, bottomY, smallFontSize, '#FFD700', 'Arial', 'center');
Â  Â  }

Â  Â  drawHUD() {
      if (!this.player) return; // ç©å®¶ä¸å­˜åœ¨æ—¶è·³è¿‡ç»˜åˆ¶
Â  Â  Â  const p = this.player;
Â  Â  Â  const hudX = 20;
Â  Â  Â  const hudY = 20;
      const smallTextSize = Math.max(16, CANVAS_HEIGHT * 0.02);
      const mediumTextSize = Math.max(20, CANVAS_HEIGHT * 0.03);
      const largeTextSize = Math.max(32, CANVAS_HEIGHT * 0.05);

Â  Â  Â  // --- HP Bar ---
Â  Â  Â  const hpBarW = Math.min(350, CANVAS_WIDTH * 0.3);
Â  Â  Â  const hpBarH = Math.max(25, CANVAS_HEIGHT * 0.035);
Â  Â  Â  const hpRatio = p.health / p.maxHealth;
Â  Â  Â  let hpColor = hpRatio > 0.6 ? 'rgb(50, 255, 50)' : (hpRatio > 0.3 ? 'rgb(255, 200, 50)' : 'rgb(255, 50, 50)');

Â  Â  Â  this.ctx.fillStyle = 'rgb(100, 30, 30)';
Â  Â  Â  this.ctx.fillRect(hudX, hudY, hpBarW, hpBarH);
Â  Â  Â  this.ctx.fillStyle = hpColor;
Â  Â  Â  this.ctx.fillRect(hudX, hudY, hpBarW * hpRatio, hpBarH);
Â  Â  Â  this.ctx.strokeStyle = 'white';
Â  Â  Â  this.ctx.lineWidth = 2;
Â  Â  Â  this.ctx.strokeRect(hudX, hudY, hpBarW, hpBarH);
Â  Â  Â  this.drawText(`HP: ${Math.floor(p.health)}/${p.maxHealth}`, hudX + 10, hudY + hpBarH * 0.7, mediumTextSize * 0.8, 'white');

Â  Â  Â  // --- EXP Bar ---
Â  Â  Â  const expBarW = hpBarW;
Â  Â  Â  const expBarH = Math.max(20, CANVAS_HEIGHT * 0.025);
Â  Â  Â  const expRatio = p.exp / p.expToNextLevel;

Â  Â  Â  this.ctx.fillStyle = 'rgb(30, 60, 100)';
Â  Â  Â  this.ctx.fillRect(hudX, hudY + hpBarH + 5, expBarW, expBarH);
Â  Â  Â  this.ctx.fillStyle = 'rgb(100, 200, 255)';
Â  Â  Â  this.ctx.fillRect(hudX, hudY + hpBarH + 5, expBarW * expRatio, expBarH);
Â  Â  Â  this.ctx.strokeStyle = 'white';
Â  Â  Â  this.ctx.lineWidth = 2;
Â  Â  Â  this.ctx.strokeRect(hudX, hudY + hpBarH + 5, expBarW, expBarH);
Â  Â  Â  this.drawText(`Lv.${p.level} - ${p.exp}/${p.expToNextLevel} XP`, hudX + 10, hudY + hpBarH + expBarH * 0.8 + 5, smallTextSize, 'white');

Â  Â  Â  // --- Wave & Kill Progress ---
Â  Â  Â  const waveInfoX = CANVAS_WIDTH / 2;
Â  Â  Â  const activeBosses = this.enemies.filter(e => e instanceof BossEnemy || e instanceof DeepBlueBoss).length;

Â  Â  Â  this.drawText(`WAVE ${this.wave}`, waveInfoX, hudY + largeTextSize * 0.8, largeTextSize, '#FFD700', 'Impact', 'center');

Â  Â  Â  const killText = `å‡»æ€ç›®æ ‡: ${this.enemiesKilledThisWave}/${this.enemiesToKillForNextWave}`;
Â  Â  Â  const bossText = `Boss: ${activeBosses} å­˜æ´»`;

Â  Â  Â  this.drawText(killText, waveInfoX, hudY + largeTextSize + mediumTextSize * 0.8, mediumTextSize, 'white', 'Arial', 'center');
Â  Â  Â  this.drawText(bossText, waveInfoX, hudY + largeTextSize + mediumTextSize * 1.8, mediumTextSize, activeBosses > 0 ? 'rgb(255, 50, 50)' : 'rgb(50, 255, 50)', 'Arial', 'center');

Â  Â  Â  // --- Score ---
Â  Â  Â  const scoreX = CANVAS_WIDTH - 20;
Â  Â  Â  this.drawText(`Score: ${Math.floor(p.score)}`, scoreX, hudY + mediumTextSize, mediumTextSize, 'white', 'Arial', 'right');

Â  Â  Â  // --- æŠ€èƒ½æŒ‡ç¤ºå™¨ (Q, C, E) ---
Â  Â  Â  const skillInfo = [
Â  Â  Â  Â  { key: 'Q', name: "æŠ¤ç›¾", color: 'rgb(0, 150, 255)', max: p.shieldMaxCooldown, current: p.shieldCooldown, active: p.isShielded },
Â  Â  Â  Â  { key: 'C', name: "å¢ä¼¤", color: 'rgb(255, 100, 0)', max: p.buffMaxCooldown, current: p.buffCooldown, active: p.isBuffed },
Â  Â  Â  Â  { key: 'E', name: "å†²å‡»æ³¢", color: 'rgb(100, 200, 255)', max: p.shockwaveMaxCooldown, current: p.shockwaveCooldown, active: p.isShockwaving }
Â  Â  Â  ];

Â  Â  Â  const skillSize = Math.min(CANVAS_WIDTH * 0.05, 70);
      const skillGap = skillSize * 1.4;
      const skillBaseX = CANVAS_WIDTH - skillGap * 2; // å‘å·¦ç§»åŠ¨ä»¥å®¹çº³3ä¸ªæŠ€èƒ½
Â  Â  Â  const skillY = CANVAS_HEIGHT - (skillSize * 0.7);


Â  Â  Â  skillInfo.forEach((skill, index) => {
Â  Â  Â  Â  const skillX = skillBaseX + index * skillGap;

Â  Â  Â  Â  const skillRatio = Math.max(0, skill.current / skill.max);

Â  Â  Â  Â  // Background
Â  Â  Â  Â  this.ctx.fillStyle = 'rgba(50, 50, 50, 0.5)';
Â  Â  Â  Â  this.ctx.fillRect(skillX - skillSize / 2, skillY - skillSize / 2, skillSize, skillSize);

Â  Â  Â  Â  // Cooldown overlay
Â  Â  Â  Â  if (skillRatio > 0) {
Â  Â  Â  Â  Â  this.ctx.fillStyle = 'rgba(20, 20, 40, 0.7)';
Â  Â  Â  Â  Â  this.ctx.fillRect(skillX - skillSize / 2, skillY - skillSize / 2, skillSize, skillSize * skillRatio);

Â  Â  Â  Â  Â  this.drawText(Math.ceil(skill.current).toString(), skillX, skillY + skillSize * 0.15, skillSize * 0.6, '#FFD700', 'Impact', 'center');
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  // Ready or Active state text
Â  Â  Â  Â  Â  const textColor = skill.active ? 'rgb(255, 255, 255)' : skill.color;

Â  Â  Â  Â  Â  if (skill.active) {
Â  Â  Â  Â  Â  Â  // Active background glow
Â  Â  Â  Â  Â  Â  this.ctx.fillStyle = skill.color;
Â  Â  Â  Â  Â  Â  this.ctx.globalAlpha = Math.sin(this.currentTime * 15) * 0.3 + 0.7;
Â  Â  Â  Â  Â  Â  this.ctx.fillRect(skillX - skillSize / 2, skillY - skillSize / 2, skillSize, skillSize);
Â  Â  Â  Â  Â  Â  this.ctx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  this.drawText(skill.key, skillX, skillY + skillSize * 0.15, skillSize * 0.6, textColor, 'Impact', 'center');
Â  Â  Â  Â  }

Â  Â  Â  Â  // Border
Â  Â  Â  Â  this.ctx.strokeStyle = skill.current > 0 ? 'rgb(100, 100, 100)' : skill.color;
Â  Â  Â  Â  this.ctx.lineWidth = 3;
Â  Â  Â  Â  this.ctx.strokeRect(skillX - skillSize / 2, skillY - skillSize / 2, skillSize, skillSize);

Â  Â  Â  Â  // Name
Â  Â  Â  Â  this.drawText(skill.name + ` (${skill.key})`, skillX, skillY + skillSize / 2 + smallTextSize, smallTextSize, 'white', 'Arial', 'center');
Â  Â  Â  });
Â  Â  }

Â  Â  drawLevelUpScreen() {
      if (!this.player) return;
Â  Â  Â  const centerX = CANVAS_WIDTH / 2;
Â  Â  Â  const centerY = CANVAS_HEIGHT / 2;
      const baseTitleSize = Math.min(CANVAS_WIDTH * 0.1, 90);
      const baseTextSize = Math.min(CANVAS_WIDTH * 0.03, 36);

Â  Â  Â  this.ctx.fillStyle = 'rgba(10, 10, 30, 0.95)';
Â  Â  Â  this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

Â  Â  Â  this.drawText("â˜… å‡ çº§! â˜…", centerX, centerY - CANVAS_HEIGHT * 0.3, baseTitleSize, '#FFD700', 'Impact', 'center');
Â  Â  Â  this.drawText(`ç­‰çº§ ${this.player.level}!`, centerX, centerY - CANVAS_HEIGHT * 0.3 + baseTitleSize * 0.7, baseTitleSize * 0.5, 'white', 'Arial', 'center');
Â  Â  Â  this.drawText("é€‰æ‹©ä¸€ä¸ªå‡çº§:", centerX, centerY - CANVAS_HEIGHT * 0.15, baseTextSize, 'white', 'Arial', 'center');

Â  Â  Â  const options = [
Â  Â  Â  Â  { key: '1', icon: 'âš”', name: "å¢åŠ ä¼¤å®³", effect: "+25% æ”»å‡»ä¼¤å®³", color: 'rgb(255, 100, 100)' },
Â  Â  Â  Â  { key: '2', icon: 'â¤', name: "å¢åŠ ç”Ÿå‘½", effect: "+30 æœ€å¤§ç”Ÿå‘½å€¼", color: 'rgb(255, 50, 150)' },
Â  Â  Â  Â  { key: '3', icon: 'â¤', name: "ç§»åŠ¨é€Ÿåº¦", effect: "+15% ç§»åŠ¨é€Ÿåº¦", color: 'rgb(100, 200, 255)' }
Â  Â  Â  ];

Â  Â  Â  let startY = centerY - 30;
Â  Â  Â  const cardW = Math.min(CANVAS_WIDTH * 0.3, 400);
Â  Â  Â  const cardH = Math.min(CANVAS_HEIGHT * 0.12, 100);
      const cardGap = cardH * 0.2;

Â  Â  Â  options.forEach((opt, index) => {
Â  Â  Â  Â  const y = startY + index * (cardH + cardGap);

Â  Â  Â  Â  this.ctx.fillStyle = opt.color;
Â  Â  Â  Â  this.ctx.globalAlpha = 0.4;
Â  Â  Â  Â  this.ctx.fillRect(centerX - cardW / 2, y, cardW, cardH);
Â  Â  Â  Â  this.ctx.globalAlpha = 1.0;
Â  Â  Â  Â  this.ctx.strokeStyle = 'white';
Â  Â  Â  Â  this.ctx.lineWidth = 4;
Â  Â  Â  Â  this.ctx.strokeRect(centerX - cardW / 2, y, cardW, cardH);

        const keySize = cardH * 0.5;
        const iconSize = cardH * 0.4;
        const titleSize = cardH * 0.3;
        const effectSize = cardH * 0.25;

Â  Â  Â  Â  this.drawText(`[${opt.key}]`, centerX - cardW / 2 + cardW * 0.1, y + cardH * 0.6, keySize, '#FFD700', 'Arial', 'left');
Â  Â  Â  Â  this.drawText(opt.icon, centerX - cardW * 0.1, y + cardH * 0.4, iconSize, 'white', 'Arial', 'left');
Â  Â  Â  Â  this.drawText(opt.name, centerX - cardW * 0.1, y + cardH * 0.75, titleSize, 'white', 'Arial', 'left');
Â  Â  Â  Â  this.drawText(opt.effect, centerX + cardW * 0.25, y + cardH * 0.6, effectSize, 'lightgray', 'Arial', 'center');
Â  Â  Â  });

Â  Â  Â  this.drawText("æŒ‰ 1, 2, æˆ– 3 é€‰æ‹©å‡çº§", centerX, CANVAS_HEIGHT - 50, baseTextSize * 0.8, 'white', 'Arial', 'center');
Â  Â  }

Â  Â  drawGameOverScreen() {
      if (!this.player) return;
Â  Â  Â  const centerX = CANVAS_WIDTH / 2;
Â  Â  Â  const centerY = CANVAS_HEIGHT / 2;
      const titleSize = Math.min(CANVAS_WIDTH * 0.12, 100);
      const largeText = Math.min(CANVAS_WIDTH * 0.05, 48);
      const mediumText = Math.min(CANVAS_WIDTH * 0.04, 36);
      const smallText = Math.min(CANVAS_WIDTH * 0.03, 30);


Â  Â  Â  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
Â  Â  Â  this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

Â  Â  Â  this.drawText("æ¸¸æˆç»“æŸ", centerX, centerY - CANVAS_HEIGHT * 0.2, titleSize, 'rgb(255, 50, 50)', 'Impact', 'center');

Â  Â  Â  this.drawText(`å¾—åˆ†: ${Math.floor(this.player.score)}`, centerX, centerY, largeText, 'white', 'Arial', 'center');
Â  Â  Â  this.drawText(`æœ€é«˜åˆ†: ${this.data.highScore}`, centerX, centerY + largeText * 1.2, mediumText, '#FFD700', 'Arial', 'center');

Â  Â  Â  const coinsGained = Math.floor(this.player.score / 2000);
Â  Â  Â  this.drawText(`æœ¬å±€è¾¾åˆ° Wave ${this.wave}`, centerX, centerY + largeText * 2.5, mediumText, 'rgb(255, 255, 0)', 'Arial', 'center');
Â  Â  Â  this.drawText(`è·å¾—é‡‘å¸: +${coinsGained}`, centerX, centerY + largeText * 3.5, smallText, 'rgb(0, 200, 0)', 'Arial', 'center');

Â  Â  Â  this.drawText("æŒ‰ R é‡æ–°å¼€å§‹ | æŒ‰ ESC è¿”å›èœå•", centerX, CANVAS_HEIGHT - 100, smallText, 'lightgray', 'Arial', 'center');
Â  Â  }

Â  Â  run() {
Â  Â  Â  const loop = (currentTime) => {
Â  Â  Â  Â  if (!this.running) return;

        // é™åˆ¶æœ€å¤§ DTï¼Œé˜²æ­¢æµè§ˆå™¨æ ‡ç­¾é¡µåˆ‡æ¢å¯¼è‡´æ¸¸æˆå´©æºƒ
Â  Â  Â  Â  const now = performance.now();
        let dt = (now - this.lastTime) / 1000.0;
        if (dt > 0.1) {
            dt = 0.1; // é™åˆ¶æœ€å¤§ dt ä¸º 0.1s
        }
        this.lastTime = now;

        if (dt > 0) {
Â  Â  Â  Â    this.update(dt);
        }
Â  Â  Â  Â  this.draw();

Â  Â  Â  Â  requestAnimationFrame(loop);
Â  Â  Â  };
      this.lastTime = performance.now(); // åˆå§‹åŒ–
Â  Â  Â  requestAnimationFrame(loop);
Â  Â  }
Â  }

Â  window.onload = () => {
Â  Â  gameInstance = new Game();
Â  };

</script>
</body>
</html>
