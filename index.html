<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DANTAO</title>
  <style>
    /* ğŸ¨ è§†è§‰è®¾è®¡ - è‰²å½©æ–¹æ¡ˆ */
    body {
      margin: 0;
      background-color: #141428; /* æ·±è“é»‘èƒŒæ™¯ */
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      user-select: none;
    }
    canvas {
      border: 3px solid #FFD700; /* ä¸»é¢˜è‰²: é‡‘è‰² */
      display: block;
      border-radius: 12px;
      box-shadow: 0 0 40px rgba(255, 215, 0, 0.2);
      background-color: #141428;
    }

    /* é¼ æ ‡æ ·å¼ï¼Œæç¤ºç©å®¶å¯ä»¥å°„å‡»/äº’åŠ¨ */
    canvas:active {
      cursor: crosshair;
    }

    /* éŸ³ä¹æ§åˆ¶æŒ‰é’®æ ·å¼ */
    #music-control {
      position: absolute;
      bottom: 20px;
      right: calc(50% - 700px + 20px); /* å®šä½åˆ°ç”»å¸ƒå·¦ä¸‹è§’ */
      background-color: rgba(255, 215, 0, 0.9);
      color: #141428;
      border: 2px solid #FFD700;
      border-radius: 8px;
      padding: 10px 15px;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    #music-control:hover {
      background-color: #FFF;
    }

    #music-control:active {
      transform: scale(0.98);
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="1400" height="900"></canvas>

<!-- éŸ³é¢‘å…ƒç´ ï¼šè®¾ç½® autoplay å’Œ loop -->
<!-- !!! è­¦å‘Šï¼šè¯·æ›¿æ¢ src ä¸­çš„é“¾æ¥ä¸ºæ‚¨çš„ MP3 æ–‡ä»¶çš„å…¬å…± URL !!! -->
<audio id="backgroundMusic" loop>
  <!-- ä¿æŒç”¨æˆ·åŸæœ‰çš„é“¾æ¥æˆ–å ä½ç¬¦é“¾æ¥ -->
  <source src="https://example.com/your-awesome-game-music.mp3" type="audio/mp3">
  æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾ã€‚
</audio>

<button id="music-control">
  ğŸ”Š éŸ³ä¹: å¼€å¯
</button>

<script>
  // --------------------------------------------------------
  // ğŸ“ ä»£ç ç»“æ„ï¼šDANTAO - æ— å°½Waveå¢å¼ºç‰ˆ (å•æ–‡ä»¶ JS å®ç°)
  // --------------------------------------------------------

  // === å…¨å±€å¸¸é‡ ===
  const CANVAS_WIDTH = 1400;
  const CANVAS_HEIGHT = 900;
  const FPS = 60;
  const BACKGROUND_COLOR = 'rgb(20, 20, 40)';
  const GRID_COLOR = 'rgb(40, 40, 60)';
  const SHOCKWAVE_COOLDOWN = 10.0; // Eé”®æŠ€èƒ½å†·å´æ—¶é—´ (ç§’)

  // çŠ¶æ€æœº
  const GameState = {
    MENU: 'menu',
    GAME: 'game',
    LEVEL_UP: 'level_up',
    GAME_OVER: 'game_over'
  };

  // çš®è‚¤é¢œè‰²
  const SkinColors = {
    default: 'rgb(0, 255, 0)',
    blue: 'rgb(0, 100, 255)',
    red: 'rgb(255, 50, 50)',
    gold: 'rgb(255, 215, 0)'
  };

  // --------------------------------------------------------
  // 1. Data/PlayerData.js - æ•°æ®æŒä¹…åŒ–
  // --------------------------------------------------------
  class PlayerData {
    constructor() {
      this.coins = 0;
      this.ownedSkins = ['default'];
      this.currentSkin = 'default';
      this.highScore = 0;
      this.loadData();
    }

    loadData() {
      try {
        // ä½¿ç”¨ sessionStorage ä»£æ›¿ localStorageï¼Œå› ä¸ºæœ¬åœ°æ–‡ä»¶è¿è¡Œå¯èƒ½é˜»æ­¢ localStorage è®¿é—®
        const dataString = sessionStorage.getItem('dantao_player_data');
        if (dataString) {
          const data = JSON.parse(dataString);
          this.coins = data.coins || 0;
          this.ownedSkins = data.owned_skins || ['default'];
          this.currentSkin = data.current_skin || 'default';
          this.highScore = data.highScore || 0;
        }
      } catch (e) {
        console.error("åŠ è½½æ•°æ®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:", e);
      }
    }

    saveData() {
      const data = {
        coins: this.coins,
        owned_skins: this.ownedSkins,
        current_skin: this.currentSkin,
        highScore: this.highScore
      };
      sessionStorage.setItem('dantao_player_data', JSON.stringify(data));
    }

    addCoins(amount) {
      this.coins += amount;
      this.saveData();
    }

    updateHighScore(score) {
      if (score > this.highScore) {
        this.highScore = score;
        this.saveData();
      }
    }

    getSkinColor() {
      return SkinColors[this.currentSkin] || SkinColors.default;
    }
  }

  // --------------------------------------------------------
  // 2. Systems/CollisionManager.js - ç¢°æ’ç³»ç»Ÿ
  // --------------------------------------------------------
  class CollisionManager {
    static checkCircleCollision(e1, e2) {
      const dx = e1.x - e2.x;
      const dy = e1.y - e2.y;
      const distanceSq = dx * dx + dy * dy;
      const radiiSum = e1.radius + e2.radius;
      return distanceSq < radiiSum * radiiSum;
    }

    static checkAndResolve(entity, targetRect) {
      const radius = entity.radius || (entity.width ? entity.width / 2 : 30);

      const eRect = {
        left: entity.x - radius,
        right: entity.x + radius,
        top: entity.y - radius,
        bottom: entity.y + radius
      };

      const tRect = targetRect;

      const overlapX = Math.max(0, Math.min(eRect.right, tRect.x + tRect.width) - Math.max(eRect.left, tRect.x));
      const overlapY = Math.max(0, Math.min(eRect.bottom, tRect.y + tRect.height) - Math.max(eRect.top, tRect.y));

      if (overlapX > 0 && overlapY > 0) {
        if (overlapX < overlapY) {
          if (eRect.left < tRect.x) {
            entity.x -= overlapX;
          } else {
            entity.x += overlapX;
          }
        } else {
          if (eRect.top < tRect.y) {
            entity.y -= overlapY;
          } else {
            entity.y += overlapY;
          }
        }
        return true;
      }
      return false;
    }
  }

  // --------------------------------------------------------
  // 3. Systems/Camera.js - æ‘„åƒæœºç³»ç»Ÿ
  // --------------------------------------------------------
  class Camera {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.x = 0;
      this.y = 0;
      this.smoothness = 0.08;
    }

    update(target, dt) {
      const targetX = target.x - this.width / 2;
      const targetY = target.y - this.height / 2;

      this.x += (targetX - this.x) * this.smoothness;
      this.y += (targetY - this.y) * this.smoothness;
    }

    worldToScreen(worldX, worldY) {
      return {
        x: worldX - this.x,
        y: worldY - this.y
      };
    }

    getViewport() {
      const inflate = 200;
      return {
        left: this.x - inflate,
        top: this.y - inflate,
        right: this.x + this.width + inflate,
        bottom: this.y + this.height + inflate
      };
    }
  }

  // --------------------------------------------------------
  // 4. Systems/RNG.js (Helper) & InfiniteWorld.js - ä¸–ç•Œç”Ÿæˆ
  // --------------------------------------------------------

  class SeededRNG {
    constructor(seed) {
      this.seed = seed % 2147483647;
      if (this.seed <= 0) this.seed += 2147483646;
    }

    next() {
      this.seed = (this.seed * 16807) % 2147483647;
      return (this.seed - 1) / 2147483646;
    }

    randFloat(min = 0, max = 1) {
      return min + this.next() * (max - min);
    }

    randInt(min, max) {
      return Math.floor(this.randFloat(min, max + 1));
    }

    choice(arr) {
      return arr[this.randInt(0, arr.length - 1)];
    }
  }

  class Building {
    constructor(x, y, width, height, type) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.type = type;
      this.health = type === 'wood' ? 50 : 150;
      this.maxHealth = this.health;
      this.isHazard = type === 'spike' || type === 'fire';
      this.isDestroyable = !this.isHazard;
      this.damage = this.isHazard ? (type === 'spike' ? 15 : 20) : 0;

      this.color = this._getColor(type);
      this.isAlive = true;
    }

    _getColor(type) {
      switch (type) {
        case 'wood': return 'rgb(139, 69, 19)';
        case 'stone': return 'rgb(100, 100, 100)';
        case 'spike': return 'rgb(150, 50, 50)';
        case 'fire': return 'rgb(255, 100, 0)';
        default: return 'gray';
      }
    }

    takeDamage(damage) {
      if (this.isDestroyable) {
        this.health -= damage;
        if (this.health <= 0) {
          this.isAlive = false;
          return true;
        }
      }
      return false;
    }

    draw(ctx, offset) {
      const screenPos = {
        x: this.x - offset.x,
        y: this.y - offset.y
      };

      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.fillRect(screenPos.x + 5, screenPos.y + 5, this.width, this.height);

      ctx.fillStyle = this.color;
      ctx.fillRect(screenPos.x, screenPos.y, this.width, this.height);

      if (this.type === 'spike') {
        ctx.fillStyle = 'black';
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          ctx.moveTo(screenPos.x + i * (this.width / 5), screenPos.y);
          ctx.lineTo(screenPos.x + (i * (this.width / 5)) + (this.width / 10), screenPos.y - 10);
          ctx.lineTo(screenPos.x + (i + 1) * (this.width / 5), screenPos.y);
        }
        ctx.fill();
      }
    }
  }

  class InfiniteWorld {
    constructor() {
      this.chunkSize = 1000;
      this.chunks = new Map();
      this.typeDistribution = [
        { type: 'wood', prob: 0.40 },
        { type: 'stone', prob: 0.30 },
        { type: 'spike', prob: 0.15 },
        { type: 'fire', prob: 0.15 }
      ];
    }

    getChunkCoords(worldX, worldY) {
      const chunkX = Math.floor(worldX / this.chunkSize);
      const chunkY = Math.floor(worldY / this.chunkSize);
      return { x: chunkX, y: chunkY };
    }

    getChunkKey(x, y) {
      return `${x},${y}`;
    }

    getVisibleContent(player) {
      const { x: pX, y: pY } = this.getChunkCoords(player.x, player.y);
      const visibleBuildings = [];
      const visibleChunkKeys = [];
      const loadDistance = 2;

      for (let i = -loadDistance; i <= loadDistance; i++) {
        for (let j = -loadDistance; j <= loadDistance; j++) {
          const chunkX = pX + i;
          const chunkY = pY + j;
          const key = this.getChunkKey(chunkX, chunkY);
          visibleChunkKeys.push({ x: chunkX, y: chunkY });

          if (!this.chunks.has(key)) {
            this.generateChunk(chunkX, chunkY);
          }

          visibleBuildings.push(...this.chunks.get(key).buildings.filter(b => b.isAlive));
        }
      }

      return {
        buildings: visibleBuildings,
        chunkKeys: visibleChunkKeys
      };
    }

    generateChunk(chunkX, chunkY) {
      const key = this.getChunkKey(chunkX, chunkY);
      const seed = (chunkX * 10000 + chunkY) * 12345;
      const rng = new SeededRNG(seed);

      const buildings = [];
      const numBuildings = rng.randInt(10, 25);

      const originX = chunkX * this.chunkSize;
      const originY = chunkY * this.chunkSize;
      const padding = 50;

      for (let i = 0; i < numBuildings; i++) {
        const typeIndex = this._getWeightedRandomType(rng);
        const type = this.typeDistribution[typeIndex].type;

        const width = rng.randInt(60, 120);
        const height = rng.randInt(60, 120);

        const x = originX + rng.randInt(padding, this.chunkSize - width - padding);
        const y = originY + rng.randInt(padding, this.chunkSize - height - padding);

        buildings.push(new Building(x, y, width, height, type));
      }

      this.chunks.set(key, { buildings: buildings, enemies: [] });
    }

    _getWeightedRandomType(rng) {
      const total = this.typeDistribution.reduce((sum, item) => sum + item.prob, 0);
      let rand = rng.randFloat(0, total);

      for (let i = 0; i < this.typeDistribution.length; i++) {
        rand -= this.typeDistribution[i].prob;
        if (rand <= 0) {
          return i;
        }
      }
      return 0;
    }

    getChunkWorldBounds(chunkX, chunkY) {
      const originX = chunkX * this.chunkSize;
      const originY = chunkY * this.chunkSize;
      return {
        x: originX,
        y: originY,
        width: this.chunkSize,
        height: this.chunkSize
      };
    }
  }


  // --------------------------------------------------------
  // 5. Entities/Player.js - ç©å®¶å®ä½“
  // --------------------------------------------------------
  class Player {
    constructor(x, y, data) {
      this.x = x;
      this.y = y;
      this.radius = 30;
      this.data = data;
      this.level = 1;
      this.score = 0;

      this.maxHealth = 100;
      this.health = 100;
      this.baseSpeed = 250;
      this.baseDamage = 15;

      this.damageMultiplier = 1.0;
      this.speedMultiplier = 1.0;

      this.isAlive = true;
      this.isInvincible = false;
      this.invincibilityTimer = 0;
      this.invincibilityDuration = 0.5;
      this.lastAttackTime = 0;
      this.attackCooldown = 0.25;

      // --- E (Shockwave) Skill ---
      this.shockwaveCooldown = 0;
      this.shockwaveMaxCooldown = SHOCKWAVE_COOLDOWN; // 10.0s
      this.shockwaveRadius = 500;
      this.shockwaveDamage = 100;
      this.isShockwaving = false;
      this.shockwaveTimer = 0.0;
      this.shockwaveDuration = 0.2;

      // --- Q (Shield) Skill - çŸ­æš‚æ— æ•ŒæŠ¤ç›¾ ---
      this.shieldCooldown = 0;
      this.shieldMaxCooldown = 15.0; // 15s å†·å´
      this.isShielded = false;
      this.shieldDuration = 2.0; // 2s æŒç»­æ—¶é—´ (é‡ç½®å€¼)

      // --- C (Damage Buff) Skill - çŸ­æš‚å¢ä¼¤ ---
      this.buffCooldown = 0;
      this.buffMaxCooldown = 20.0; // 20s å†·å´
      this.isBuffed = false;
      this.buffDuration = 5.0; // 5s æŒç»­æ—¶é—´ (é‡ç½®å€¼)
      this.baseBuffMultiplier = 1.0; // 100% ä¼¤å®³åŠ æˆ (æ€»ä¹˜æ•° * 2.0)

      this.exp = 0;
      this.expToNextLevel = 100;
      this.expGrowthRate = 1.4;

      this.aimAngle = 0;
    }

    // --- Q æŠ€èƒ½ (æŠ¤ç›¾) ---
    useShield(currentTime) {
      if (this.shieldCooldown <= 0) {
        this.shieldCooldown = this.shieldMaxCooldown;
        this.isShielded = true;
        this.shieldDuration = 2.0; // å¯åŠ¨æ—¶é‡ç½®æŒç»­æ—¶é—´
        return true;
      }
      return false;
    }

    // --- C æŠ€èƒ½ (å¢ä¼¤) ---
    useDamageBuff(currentTime) {
      if (this.buffCooldown <= 0) {
        this.buffCooldown = this.buffMaxCooldown;
        this.isBuffed = true;
        this.damageMultiplier += this.baseBuffMultiplier; // å¢åŠ ä¼¤å®³ä¹˜æ•° (1.0 -> 2.0)
        this.buffDuration = 5.0; // å¯åŠ¨æ—¶é‡ç½®æŒç»­æ—¶é—´
        return true;
      }
      return false;
    }

    useShockwave(currentTime) {
      if (this.shockwaveCooldown <= 0) {
        this.shockwaveCooldown = this.shockwaveMaxCooldown;
        this.isShockwaving = true;
        this.shockwaveTimer = this.shockwaveDuration;
        return true;
      }
      return false;
    }

    gainExp(amount) {
      this.exp += amount;
      while (this.exp >= this.expToNextLevel) {
        this.levelUp();
      }
    }

    levelUp() {
      this.level += 1;
      this.exp -= this.expToNextLevel;
      this.expToNextLevel = Math.floor(100 * (this.expGrowthRate ** this.level));

      this.health += this.maxHealth * 0.3;
      if (this.health > this.maxHealth) this.health = this.maxHealth;

      gameInstance.setState(GameState.LEVEL_UP);
    }

    applyUpgrade(type) {
      switch(type) {
        case 'damage':
          this.damageMultiplier += 0.25;
          break;
        case 'health':
          this.maxHealth += 30;
          this.health += 30;
          break;
        case 'speed':
          this.speedMultiplier += 0.15;
          break;
      }
      gameInstance.setState(GameState.GAME);
    }

    takeDamage(damage) {
      // 1. æ£€æŸ¥æŠ¤ç›¾ (Q æŠ€èƒ½)
      if (this.isShielded) {
        // æŠ¤ç›¾å¸æ”¶ä¼¤å®³ï¼Œä¸è§¦å‘çŸ­æš‚æ— æ•Œ
        return true;
      }

      // 2. æ£€æŸ¥çŸ­æš‚æ— æ•Œ (ç”±ä¼¤å®³è§¦å‘)
      if (!this.isAlive || this.isInvincible) return false;

      this.health -= damage;

      this.isInvincible = true;
      this.invincibilityTimer = this.invincibilityDuration;

      if (this.health <= 0) {
        this.health = 0;
        this.isAlive = false;
        gameInstance.setState(GameState.GAME_OVER);
      }
      return true;
    }

    attack(currentTime, targetX, targetY) {
      if (currentTime >= this.lastAttackTime + this.attackCooldown) {
        this.lastAttackTime = currentTime;

        // finalDamage åŒ…å«äº† Level Up çš„ damageMultiplier å’Œ C-Skill çš„ buffMultiplier
        const finalDamage = this.baseDamage * this.damageMultiplier;
        const speed = 600;

        const dx = targetX - this.x;
        const dy = targetY - this.y;
        this.aimAngle = Math.atan2(dy, dx);

        return new Projectile(this.x, this.y, this.aimAngle, speed, finalDamage, this, 'player');
      }
      return null;
    }

    handleInput(input, dt) {
      let velX = 0;
      let velY = 0;
      const currentSpeed = this.baseSpeed * this.speedMultiplier;

      if (input.keys['w']) velY -= 1;
      if (input.keys['s']) velY += 1;
      if (input.keys['a']) velX -= 1;
      if (input.keys['d']) velX += 1;

      if (gameInstance.state === GameState.GAME) {
        // E æŠ€èƒ½è¾“å…¥
        if (input.keys['e']) {
          this.useShockwave(gameInstance.currentTime);
        }
        // Q æŠ€èƒ½è¾“å…¥ (æŠ¤ç›¾)
        if (input.keys['q']) {
          this.useShield(gameInstance.currentTime);
        }
        // C æŠ€èƒ½è¾“å…¥ (å¢ä¼¤)
        if (input.keys['c']) {
          this.useDamageBuff(gameInstance.currentTime);
        }
      }

      if (velX !== 0 || velY !== 0) {
        const magnitude = Math.sqrt(velX * velX + velY * velY);
        velX /= magnitude;
        velY /= magnitude;
      }

      this.x += velX * currentSpeed * dt;
      this.y += velY * currentSpeed * dt;

      const dx = input.mouse.worldX - this.x;
      const dy = input.mouse.worldY - this.y;
      this.aimAngle = Math.atan2(dy, dx);
    }

    update(dt) {
      this.score += 1 * dt;

      // Invincibility update
      if (this.isInvincible) {
        this.invincibilityTimer -= dt;
        if (this.invincibilityTimer <= 0) {
          this.isInvincible = false;
        }
      }

      // E Skill Cooldown/Timer update
      if (this.shockwaveCooldown > 0) {
        this.shockwaveCooldown -= dt;
      }

      if (this.isShockwaving) {
        this.shockwaveTimer -= dt;
        if (this.shockwaveTimer <= 0) {
          this.isShockwaving = false;
        }
      }

      // Q Skill Cooldown/Timer update (Shield)
      if (this.shieldCooldown > 0) {
        this.shieldCooldown -= dt;
      }
      if (this.isShielded) {
        this.shieldDuration -= dt;
        if (this.shieldDuration <= 0) {
          this.isShielded = false;
          this.shieldDuration = 2.0; // Reset duration for next use
        }
      }

      // C Skill Cooldown/Timer update (Damage Buff)
      if (this.buffCooldown > 0) {
        this.buffCooldown -= dt;
      }
      if (this.isBuffed) {
        this.buffDuration -= dt;
        if (this.buffDuration <= 0) {
          this.isBuffed = false;
          this.damageMultiplier -= this.baseBuffMultiplier; // ç§»é™¤ä¼¤å®³åŠ æˆ
          this.buffDuration = 5.0; // Reset duration for next use
        }
      }

      gameInstance.buildings.forEach(b => {
        const trapContact = {
          x: b.x + b.width / 2,
          y: b.y + b.height / 2,
          radius: Math.min(b.width, b.height) / 2
        };
        if (b.isHazard && CollisionManager.checkCircleCollision(this, trapContact)) {
          this.takeDamage(b.damage * dt);
        }
      });
    }

    draw(ctx, offset) {
      const screenPos = gameInstance.camera.worldToScreen(this.x, this.y);

      // --- Q æŠ€èƒ½æŠ¤ç›¾æ•ˆæœ ---
      if (this.isShielded) {
        const radius = this.radius * 1.5;
        const flash = Math.abs(Math.sin(gameInstance.currentTime * 10)); // è„‰å†²æ•ˆæœ

        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(0, 150, 255, ${0.5 + flash * 0.3})`;
        ctx.lineWidth = 8;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, this.radius + 5, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(0, 100, 255, 0.4)`;
        ctx.fill();
      }

      // --- E æŠ€èƒ½å†²å‡»æ³¢æ•ˆæœ ---
      if (this.isShockwaving) {
        const progress = 1 - (this.shockwaveTimer / this.shockwaveDuration);
        const currentRadius = progress * this.shockwaveRadius;

        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, currentRadius, 0, Math.PI * 2);

        const alpha = 0.5 - progress * 0.5;
        ctx.strokeStyle = `rgba(200, 200, 255, ${alpha})`;
        ctx.lineWidth = 15 + (1 - progress) * 20;
        ctx.stroke();
      }

      const isFlashing = this.isInvincible && (Math.floor(this.invincibilityTimer * 10) % 2 === 0);

      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = isFlashing ? 'white' : this.data.getSkinColor();
      ctx.fill();

      ctx.strokeStyle = 'black';
      ctx.lineWidth = 3;
      ctx.stroke();

      // --- C æŠ€èƒ½å¢ä¼¤æ•ˆæœ ---
      if (this.isBuffed) {
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, this.radius * 0.8, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 100, 0, 0.8)';
        ctx.lineWidth = 5;
        ctx.stroke();
      }

      const eyeRadius = 12;
      const pupilRadius = 6;
      const eyeOffset = 10;

      const eyeX = screenPos.x + Math.cos(this.aimAngle) * (this.radius - eyeRadius);
      const eyeY = screenPos.y + Math.sin(this.aimAngle) * (this.radius - eyeRadius);

      const pupilX = eyeX + Math.cos(this.aimAngle) * eyeOffset;
      const pupilY = eyeY + Math.sin(this.aimAngle) * eyeOffset;

      ctx.beginPath();
      ctx.arc(eyeX, eyeY, eyeRadius, 0, Math.PI * 2);
      ctx.fillStyle = 'white';
      ctx.fill();

      ctx.beginPath();
      ctx.arc(pupilX, pupilY, pupilRadius, 0, Math.PI * 2);
      ctx.fillStyle = 'black';
      ctx.fill();
    }
  }

  // --------------------------------------------------------
  // 6. Entities/Projectile.js - æŠ•å°„ç‰©ç³»ç»Ÿ
  // --------------------------------------------------------
  class Projectile {
    constructor(x, y, angle, speed, damage, owner, type) {
      this.x = x;
      this.y = y;
      this.angle = angle;
      this.speed = speed;
      this.damage = damage;
      this.owner = owner;
      this.type = type;
      this.radius = 8;
      this.velX = Math.cos(angle) * speed;
      this.velY = Math.sin(angle) * speed;
      this.lifetime = 3.0;
      this.isAlive = true;

      this.color = type === 'player' ? 'rgb(255, 215, 0)' : 'rgb(255, 50, 50)';
    }

    update(dt) {
      this.x += this.velX * dt;
      this.y += this.velY * dt;
      this.lifetime -= dt;

      if (this.lifetime <= 0) {
        this.isAlive = false;
      }
    }

    draw(ctx, offset) {
      const screenPos = gameInstance.camera.worldToScreen(this.x, this.y);

      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, this.radius * 2, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${this.color.slice(4, -1)}, 0.2)`;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, this.radius / 2, 0, Math.PI * 2);
      ctx.fillStyle = 'rgb(255, 255, 200)';
      ctx.fill();
    }
  }

  // --------------------------------------------------------
  // 7. Entities/Enemy.js - æ•Œäººç³»ç»Ÿ
  // --------------------------------------------------------

  class EnemyBase {
    constructor() {
      this.isAlive = true;
      this.knockbackVelX = 0;
      this.knockbackVelY = 0;
    }

    drawHealthBar(ctx, screenPos) {
      const barWidth = 40;
      const barHeight = 5;
      const healthRatio = this.health / this.maxHealth;

      ctx.fillStyle = 'rgb(100, 30, 30)';
      ctx.fillRect(screenPos.x - barWidth / 2, screenPos.y - this.radius - 15, barWidth, barHeight);

      ctx.fillStyle = healthRatio > 0.6 ? 'rgb(50, 255, 50)' : 'rgb(255, 200, 50)';
      ctx.fillRect(screenPos.x - barWidth / 2, screenPos.y - this.radius - 15, barWidth * healthRatio, barHeight);
    }

    applyKnockback(angle, force) {
      this.knockbackVelX = Math.cos(angle) * force;
      this.knockbackVelY = Math.sin(angle) * force;
    }

    updateMovement(dt, speed) {
      this.x += this.knockbackVelX * dt;
      this.y += this.knockbackVelY * dt;

      const decayRate = 0.9;
      this.knockbackVelX *= decayRate;
      this.knockbackVelY *= decayRate;

      if (Math.abs(this.knockbackVelX) < 10) this.knockbackVelX = 0;
      if (Math.abs(this.knockbackVelY) < 10) this.knockbackVelY = 0;
    }
  }

  /** æ™®é€šå°„æ‰‹æ•Œäºº */
  class NormalShooter extends EnemyBase {
    constructor(x, y) {
      super();
      this.x = x;
      this.y = y;
      this.radius = 25;
      this.maxHealth = 40;
      this.health = 40;
      this.speed = 100;
      this.damage = 8;
      this.expValue = 15;
      this.color = 'rgb(255, 100, 100)';
      this.attackCooldown = 2.0;
      this.lastAttackTime = 0;
      this.attackRange = 350;
      this.alertRange = 500;
    }

    takeDamage(damage) {
      this.health -= damage;
      if (this.health <= 0) {
        this.isAlive = false;
        gameInstance.player.gainExp(this.expValue);
        gameInstance.player.score += this.expValue;
        gameInstance.enemiesKilledThisWave += 1; // è®¡å…¥ WAVE å‡»æ€
        return true;
      }
      return false;
    }

    update(dt, currentTime, target) {
      if (!this.isAlive) return;

      this.updateMovement(dt, this.speed);
      if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) return;

      const dx = target.x - this.x;
      const dy = target.y - this.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);

      const speed = this.speed;

      if (distance < this.alertRange) {
        let moveX = Math.cos(angle);
        let moveY = Math.sin(angle);

        if (distance < 200) {
          moveX *= -1;
          moveY *= -1;
        } else if (distance > 300) {
        } else {
          moveX = 0;
          moveY = 0;
        }

        this.x += moveX * speed * dt;
        this.y += moveY * speed * dt;

        if (distance < this.attackRange && currentTime >= this.lastAttackTime + this.attackCooldown) {
          this.lastAttackTime = currentTime;
          this.shoot(angle);
        }
      }
    }

    shoot(angle) {
      const speed = 400;
      const damage = this.damage;
      const projectile = new Projectile(this.x, this.y, angle, speed, damage, this, 'enemy');
      gameInstance.projectiles.push(projectile);
    }

    draw(ctx, offset) {
      const screenPos = gameInstance.camera.worldToScreen(this.x, this.y);

      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.stroke();

      this.drawHealthBar(ctx, screenPos);
    }
  }

  /** å¿«é€Ÿè¿‘æˆ˜æ•Œäºº */
  class FastMeleeEnemy extends EnemyBase {
    constructor(x, y) {
      super();
      this.x = x;
      this.y = y;
      this.width = 30;
      this.height = 30;
      this.radius = 20;
      this.maxHealth = 20;
      this.health = 20;
      this.speed = 350;
      this.damage = 5;
      this.expValue = 8;
      this.color = 'rgb(50, 255, 255)';
    }

    takeDamage(damage) {
      this.health -= damage;
      if (this.health <= 0) {
        this.isAlive = false;
        gameInstance.player.gainExp(this.expValue);
        gameInstance.player.score += this.expValue;
        gameInstance.enemiesKilledThisWave += 1; // è®¡å…¥ WAVE å‡»æ€
        return true;
      }
      return false;
    }

    update(dt, currentTime, target) {
      if (!this.isAlive) return;

      this.updateMovement(dt, this.speed);
      if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) return;

      const dx = target.x - this.x;
      const dy = target.y - this.y;
      const angle = Math.atan2(dy, dx);

      this.x += Math.cos(angle) * this.speed * dt;
      this.y += Math.sin(angle) * this.speed * dt;
    }

    draw(ctx, offset) {
      const screenPos = gameInstance.camera.worldToScreen(this.x, this.y);
      const halfW = this.width / 2;
      const halfH = this.height / 2;

      ctx.fillStyle = this.color;
      ctx.fillRect(screenPos.x - halfW, screenPos.y - halfH, this.width, this.height);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.strokeRect(screenPos.x - halfW, screenPos.y - halfH, this.width, this.height);

      this.drawHealthBar(ctx, screenPos);
    }
  }

  /** Boss æ•Œäºº (Wave ä¸»è¦ç›®æ ‡ä¹‹ä¸€) */
  class BossEnemy extends EnemyBase {
    constructor(x, y) {
      super();
      this.x = x;
      this.y = y;
      this.radius = 70;
      // Boss è¡€é‡éš Wave æå‡
      this.maxHealth = 500 + gameInstance.wave * 200;
      this.health = this.maxHealth;
      this.speed = 50;
      this.damage = 25;
      this.expValue = 300;
      this.color = 'rgb(100, 50, 150)';
      this.attackCooldown = 5.0;
      this.lastAttackTime = 0;
      this.numProjectiles = 12;
    }

    takeDamage(damage) {
      this.health -= damage;
      if (this.health <= 0) {
        this.isAlive = false;
        gameInstance.player.gainExp(this.expValue);
        gameInstance.player.score += this.expValue * 5;
        // Boss æ­»äº¡ä¸è®¡å…¥ enemiesKilledThisWaveï¼Œä½†å…¶æ­»äº¡æ˜¯ Wave ç»“æŸçš„å¿…è¦æ¡ä»¶ã€‚
        return true;
      }
      return false;
    }

    update(dt, currentTime, target) {
      if (!this.isAlive) return;

      this.updateMovement(dt, this.speed);
      if (this.knockbackVelX !== 0 || this.knockbackVelY !== 0) return;

      const dx = target.x - this.x;
      const dy = target.y - this.y;
      const angle = Math.atan2(dy, dx);

      this.x += Math.cos(angle) * this.speed * dt;
      this.y += Math.sin(angle) * this.speed * dt;

      if (currentTime >= this.lastAttackTime + this.attackCooldown) {
        this.lastAttackTime = currentTime;
        this.shootRadial();
      }
    }

    shootRadial() {
      const speed = 300;
      const damage = this.damage;
      const projectiles = [];

      for (let i = 0; i < this.numProjectiles; i++) {
        const angle = (i / this.numProjectiles) * Math.PI * 2;
        projectiles.push(new Projectile(this.x, this.y, angle, speed, damage, this, 'enemy'));
      }
      gameInstance.projectiles.push(...projectiles);
    }

    draw(ctx, offset) {
      const screenPos = gameInstance.camera.worldToScreen(this.x, this.y);

      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.strokeStyle = '#FFD700';
      ctx.lineWidth = 5;
      ctx.stroke();

      ctx.fillStyle = '#FFD700';
      const crownBaseY = screenPos.y - this.radius;

      ctx.beginPath();
      ctx.moveTo(screenPos.x - this.radius * 0.5, crownBaseY);
      ctx.lineTo(screenPos.x + this.radius * 0.5, crownBaseY);

      for(let i = -2; i <= 2; i++) {
        const tipX = screenPos.x + i * (this.radius * 0.2);
        const tipY = crownBaseY - 20;
        ctx.lineTo(tipX, tipY);
        ctx.lineTo(tipX + (this.radius * 0.1), crownBaseY);
      }
      ctx.closePath();
      ctx.fill();

      this.drawHealthBar(ctx, screenPos);
    }
  }


  // --------------------------------------------------------
  // 8. Game - æ¸¸æˆä¸»æ§åˆ¶å±‚ (Wave é€»è¾‘æ ¸å¿ƒ)
  // --------------------------------------------------------

  let gameInstance;

  class Game {
    constructor() {
      this.canvas = document.getElementById('gameCanvas');
      this.ctx = this.canvas.getContext('2d');
      this.musicControl = document.getElementById('music-control');
      this.bgm = document.getElementById('backgroundMusic');

      this.data = new PlayerData();
      this.camera = new Camera(CANVAS_WIDTH, CANVAS_HEIGHT);
      this.world = new InfiniteWorld();

      this.state = GameState.MENU;
      this.running = true;

      this.player = null;
      this.enemies = [];
      this.projectiles = [];
      this.buildings = [];

      this.lastTime = 0;
      this.currentTime = 0;

      // --- Wave æ ¸å¿ƒå±æ€§ ---
      this.wave = 1;
      this.enemiesKilledThisWave = 0;
      this.enemiesSpawnedThisWave = 0; // æ–°å¢: æœ¬æ³¢å·²ç”Ÿæˆçš„æ•Œäººæ•°é‡
      this.enemiesToKillForNextWave = 100; // Wave 1 ç›®æ ‡
      this.isWaveTransition = false; // Wave è½¬æ¢æœŸé—´çš„æš‚åœå’Œæç¤º
      this.waveTransitionTimer = 0.0;
      this.baseMaxEnemies = 40; // åŸºç¡€æœ€å¤§æ•Œäººæ•°é‡ (å±å¹•ä¸Šçš„è½¯ä¸Šé™)
      this.enemySpawnTimer = 0; // æŒç»­ç”Ÿæˆè®¡æ—¶å™¨

      this.input = {
        keys: {},
        mouse: { x: 0, y: 0, worldX: 0, worldY: 0, leftClick: false }
      };

      this.setupEventListeners();
      this.updateMusicControlUI();
      this.run();
    }

    setState(newState) {
      this.state = newState;
      if (newState === GameState.GAME) {
        this.lastTime = performance.now();
        // å°è¯•åœ¨æ¸¸æˆå¼€å§‹æ—¶æ’­æ”¾éŸ³ä¹ (ç»•è¿‡æµè§ˆå™¨é™åˆ¶)
        this.bgm.play().catch(e => console.log("Music autoplay failed, user needs interaction."));
      }
    }

    toggleMusic() {
      if (this.bgm.paused) {
        this.bgm.play().catch(e => console.error("æ— æ³•æ’­æ”¾éŸ³ä¹:", e));
      } else {
        this.bgm.pause();
      }
      this.updateMusicControlUI();
    }

    updateMusicControlUI() {
      if (this.bgm.paused) {
        this.musicControl.textContent = 'ğŸ”‡ éŸ³ä¹: å…³é—­';
        this.musicControl.style.backgroundColor = 'rgba(255, 50, 50, 0.9)';
      } else {
        this.musicControl.textContent = 'ğŸ”Š éŸ³ä¹: å¼€å¯';
        this.musicControl.style.backgroundColor = 'rgba(255, 215, 0, 0.9)';
      }
    }

    setupEventListeners() {
      document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        this.input.keys[key] = true;
        this.handleGameStateInput(key);
      });

      document.addEventListener('keyup', (e) => {
        const key = e.key.toLowerCase();
        this.input.keys[key] = false;
      });

      this.canvas.addEventListener('mousedown', (e) => {
        if (e.button === 0) this.input.mouse.leftClick = true;
        if (this.state === GameState.MENU || this.state === GameState.GAME_OVER) {
          this.handleMenuClick(this.input.mouse.x, this.input.mouse.y);
        }
      });

      this.canvas.addEventListener('mouseup', (e) => {
        if (e.button === 0) this.input.mouse.leftClick = false;
      });

      this.canvas.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.input.mouse.x = e.clientX - rect.left;
        this.input.mouse.y = e.clientY - rect.top;

        if (this.camera) {
          this.input.mouse.worldX = this.input.mouse.x + this.camera.x;
          this.input.mouse.worldY = this.input.mouse.y + this.camera.y;
        }
      });

      // éŸ³ä¹æ§åˆ¶æŒ‰é’®äº‹ä»¶
      this.musicControl.addEventListener('click', () => this.toggleMusic());
    }

    handleGameStateInput(key) {
      if (this.state === GameState.GAME_OVER) {
        if (key === 'r') this.newGame();
        if (key === 'escape') this.setState(GameState.MENU);
      } else if (this.state === GameState.LEVEL_UP) {
        if (key === '1' || key === '2' || key === '3') {
          let upgradeType;
          if (key === '1') upgradeType = 'damage';
          else if (key === '2') upgradeType = 'health';
          else if (key === '3') upgradeType = 'speed';

          this.player.applyUpgrade(upgradeType);
        }
      }
    }

    handleMenuClick(mouseX, mouseY) {
      if (this.state === GameState.MENU) {
        const startButton = { x: 550, y: 400, w: 300, h: 60 };
        if (mouseX > startButton.x && mouseX < startButton.x + startButton.w &&
          mouseY > startButton.y && mouseY < startButton.y + startButton.h) {
          this.newGame();
        }
      }
    }

    newGame() {
      this.player = new Player(0, 0, this.data);
      this.enemies = [];
      this.projectiles = [];
      this.buildings = [];
      this.player.score = 0;

      // é‡ç½® Wave çŠ¶æ€
      this.wave = 1;
      this.enemiesKilledThisWave = 0;
      this.enemiesSpawnedThisWave = 0;
      this.isWaveTransition = false;
      this.waveTransitionTimer = 0.0;
      this.world.chunks.clear();

      this.startNextWave(true); // å¯åŠ¨ Wave 1
      this.setState(GameState.GAME);
    }

    startNextWave(isInitial = false) {
      if (!isInitial) {
        this.wave += 1;
      }

      // --- Wave ç›®æ ‡è®¡ç®— ---
      // Wave 1: 100, Wave 2: 150, Wave 3: 200, ...
      this.enemiesToKillForNextWave = 100 + (this.wave - 1) * 50;
      this.enemiesKilledThisWave = 0;
      this.enemiesSpawnedThisWave = 0;

      // Wave è½¬æ¢æç¤º
      this.isWaveTransition = true;
      this.waveTransitionTimer = 3.0; // 3ç§’è¿‡æ¸¡æ—¶é—´

      // 1. ç«‹å³ç”Ÿæˆå¯†é›†æ™®é€šæ•Œäºº (è¾¾æˆç›®æ ‡çš„ç¬¬ä¸€éƒ¨åˆ†)
      this.spawnWaveInitialEnemies(this.enemiesToKillForNextWave + 20);

      // 2. åªæœ‰ Wave 2 åŠä»¥åæ‰ç”Ÿæˆ Boss
      if (this.wave >= 2) {
        this.spawnWaveBosses(this.wave); // ç”Ÿæˆ X ä¸ª Boss
      }
    }

    /**
     * åœ¨ Wave å¼€å§‹æ—¶ï¼Œåœ¨ç©å®¶å‘¨å›´ä¸€å®šèŒƒå›´å†…å¯†é›†ç”Ÿæˆæ‰€æœ‰æ™®é€šæ•Œäººç›®æ ‡ã€‚
     * @param {number} count è¦ç”Ÿæˆçš„æ•Œäººæ€»æ•°
     */
    spawnWaveInitialEnemies(count) {
      const rng = new SeededRNG(performance.now());
      const spawnRadiusMin = 300; // é¿å…å‡ºç”Ÿç‚¹é‡å 
      const spawnRadiusMax = 1500; // åˆå§‹æ•£å¸ƒèŒƒå›´

      for (let i = 0; i < count; i++) {
        const angle = rng.randFloat(0, Math.PI * 2);
        const distance = rng.randFloat(spawnRadiusMin, spawnRadiusMax);

        const spawnX = this.player.x + Math.cos(angle) * distance;
        const spawnY = this.player.y + Math.sin(angle) * distance;

        let enemy;
        // æ•Œäººç±»åˆ·æ–°æƒé‡: 50% Shooter, 50% Melee
        const choice = rng.randFloat(0, 1);

        if (choice < 0.5) {
          enemy = new NormalShooter(spawnX, spawnY);
        } else {
          enemy = new FastMeleeEnemy(spawnX, spawnY);
        }
        this.enemies.push(enemy);
        this.enemiesSpawnedThisWave += 1;
      }
    }

    spawnWaveBosses(numBosses) {
      const rng = new SeededRNG(performance.now() + 1); // Use slightly different seed
      const spawnDistance = 2000; // ç¡®ä¿ Boss è¶³å¤Ÿè¿œ

      for (let i = 0; i < numBosses; i++) {
        const angle = rng.randFloat(0, Math.PI * 2);

        const spawnX = this.player.x + Math.cos(angle) * spawnDistance;
        const spawnY = this.player.y + Math.sin(angle) * spawnDistance;

        const boss = new BossEnemy(spawnX, spawnY);
        this.enemies.push(boss);
      }
    }

    update(dt) {
      this.currentTime = performance.now() / 1000.0;

      if (this.state !== GameState.GAME) return;

      // 1. Wave è½¬æ¢è®¡æ—¶å™¨ (æš‚åœæ¸¸æˆé€»è¾‘)
      if (this.isWaveTransition) {
        this.waveTransitionTimer -= dt;
        if (this.waveTransitionTimer <= 0) {
          this.isWaveTransition = false;
        }
        // è½¬æ¢æœŸé—´åªå…è®¸ç©å®¶ç§»åŠ¨å’Œé‡Šæ”¾æŠ€èƒ½ (åŒ…æ‹¬æ›´æ–°å†·å´)
        this.player.handleInput(this.input, dt);
        this.player.update(dt);
        this.camera.update(this.player, dt);
        return;
      }

      // 2. Wave æ¨è¿›æ£€æŸ¥
      const activeBosses = this.enemies.filter(e => e instanceof BossEnemy).length;
      if (this.enemiesKilledThisWave >= this.enemiesToKillForNextWave && activeBosses === 0) {
        this.startNextWave();
      }

      // 3. ç©å®¶æ›´æ–°
      this.player.handleInput(this.input, dt);
      this.player.update(dt);

      // 4. ä¸–ç•Œå’Œå»ºç­‘åŠ è½½
      const worldContent = this.world.getVisibleContent(this.player);
      this.buildings = worldContent.buildings;

      // 5. æ•ŒäººæŒç»­ç”Ÿæˆ (è½¯ä¸Šé™æ§åˆ¶)
      this.enemySpawnTimer += dt;

      // éš¾åº¦ç¼©æ”¾: Wave è¶Šé«˜ï¼Œæœ€å¤§æ•Œäººæ•°é‡è¶Šå¤šï¼Œç”Ÿæˆè¶Šå¿«
      const maxEnemyScale = 1 + this.wave * 0.15;
      const currentMaxEnemies = Math.min(250, Math.floor(this.baseMaxEnemies * maxEnemyScale));
      const continuousSpawnRate = 0.5; // æŒç»­ç”Ÿæˆé—´éš” (ç§’)

      const currentNormalEnemies = this.enemies.filter(e => !(e instanceof BossEnemy)).length;

      // åªæœ‰å½“åœºä¸Šæ™®é€šæ•Œäººæ•°é‡ä½äºè½¯ä¸Šé™ï¼Œä¸”å·²ç”Ÿæˆçš„æ•Œäººæ€»æ•°æœªè¾¾åˆ°æœ¬æ³¢ç›®æ ‡æ—¶ï¼Œæ‰æŒç»­ç”Ÿæˆ
      if (currentNormalEnemies < currentMaxEnemies && this.enemiesSpawnedThisWave < this.enemiesToKillForNextWave && this.enemySpawnTimer > continuousSpawnRate) {
        this.spawnSingleEnemy(worldContent.chunkKeys);
        this.enemiesSpawnedThisWave += 1;
        this.enemySpawnTimer = 0;
      }

      // 6. å®ä½“å’ŒæŠ•å°„ç‰©æ›´æ–°
      this.enemies.forEach(e => e.update(dt, this.currentTime, this.player));
      this.projectiles.forEach(p => p.update(dt));

      // 7. æˆ˜æ–—å’Œç¢°æ’æ£€æµ‹
      this.handleCollisions(dt);

      // 8. è¿‡æ»¤å·²æ­»äº¡/è¶…æ—¶çš„å®ä½“
      this.projectiles = this.projectiles.filter(p => p.isAlive);
      this.enemies = this.enemies.filter(e => e.isAlive);
      this.buildings = this.buildings.filter(b => b.isAlive);

      // 9. ç©å®¶æ”»å‡»
      if (this.input.mouse.leftClick) {
        const newProjectile = this.player.attack(this.currentTime, this.input.mouse.worldX, this.input.mouse.worldY);
        if (newProjectile) {
          this.projectiles.push(newProjectile);
        }
      }

      // 10. æ‘„åƒæœºè·Ÿéš
      this.camera.update(this.player, dt);

      // 11. æ­»äº¡æ£€æŸ¥
      if (!this.player.isAlive) {
        this.data.updateHighScore(Math.floor(this.player.score));
        const coinsGained = Math.floor(this.player.score / 2000);
        this.data.addCoins(coinsGained);
        this.setState(GameState.GAME_OVER);
      }
    }

    /**
     * åœ¨å¯è§åŒºåŸŸå¤–éšæœºç”Ÿæˆå•ä¸ªæ•Œäºº (ç”¨äºæŒç»­è¡¥å……)
     */
    spawnSingleEnemy(chunkKeys) {
      if (chunkKeys.length === 0) return;

      const rng = new SeededRNG(performance.now() + 2); // Use slightly different seed
      const targetChunkCoords = rng.choice(chunkKeys);
      const bounds = this.world.getChunkWorldBounds(targetChunkCoords.x, targetChunkCoords.y);

      let spawnX = rng.randFloat(bounds.x, bounds.x + bounds.width);
      let spawnY = rng.randFloat(bounds.y, bounds.y + bounds.height);

      const screenDist = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) / 2 + 100;
      const distToPlayer = Math.sqrt((spawnX - this.player.x) ** 2 + (spawnY - this.player.y) ** 2);

      // ç¡®ä¿ç”Ÿæˆåœ¨å±å¹•å¤–
      if (distToPlayer < screenDist) {
        const angle = Math.atan2(spawnY - this.player.y, spawnX - this.player.x);
        spawnX = this.player.x + Math.cos(angle) * screenDist;
        spawnY = this.player.y + Math.sin(angle) * screenDist;
      }

      let enemy;
      // æ•Œäººç±»åˆ·æ–°æƒé‡: 50% Shooter, 50% Melee
      const choice = rng.randFloat(0, 1);

      if (choice < 0.5) {
        enemy = new NormalShooter(spawnX, spawnY);
      } else {
        enemy = new FastMeleeEnemy(spawnX, spawnY);
      }

      this.enemies.push(enemy);
    }

    handleCollisions(dt) {
      // --- E é”®å†²å‡»æ³¢æ•ˆæœ ---
      if (this.player.isShockwaving && this.player.shockwaveTimer >= this.player.shockwaveDuration - dt) {
        const shockwaveDamage = this.player.shockwaveDamage * this.player.damageMultiplier;
        const knockbackForce = 1500;

        this.enemies.forEach(e => {
          if (e.isAlive) {
            const dx = e.x - this.player.x;
            const dy = e.y - this.player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.player.shockwaveRadius) {
              e.takeDamage(shockwaveDamage);
              const angle = Math.atan2(dy, dx);
              e.applyKnockback(angle, knockbackForce);
            }
          }
        });
      }

      // --- ç©å®¶ vs å»ºç­‘ ---
      this.buildings.forEach(b => {
        CollisionManager.checkAndResolve(this.player, b);
      });

      // --- æŠ•å°„ç‰© vs å®ä½“/å»ºç­‘ ---
      this.projectiles.forEach(p => {
        if (!p.isAlive) return;

        if (p.type === 'player') {
          this.enemies.forEach(e => {
            if (e.isAlive && CollisionManager.checkCircleCollision(p, e)) {
              e.takeDamage(p.damage);
              p.isAlive = false;
            }
          });

          this.buildings.forEach(b => {
            if (b.isDestroyable && p.x > b.x && p.x < b.x + b.width && p.y > b.y && p.y < b.y + b.height) {
              b.takeDamage(p.damage);
              p.isAlive = false;
            }
          });

        } else if (p.type === 'enemy') {
          if (this.player.isAlive && CollisionManager.checkCircleCollision(p, this.player)) {
            this.player.takeDamage(p.damage);
            p.isAlive = false;
          }
        }
      });

      // --- æ•Œäºº vs ç©å®¶ (æ¥è§¦ä¼¤å®³) ---
      this.enemies.forEach(e => {
        if (e.isAlive && CollisionManager.checkCircleCollision(e, this.player)) {
          if (e instanceof FastMeleeEnemy) {
            this.player.takeDamage(e.damage * dt * 5);
          } else {
            this.player.takeDamage(e.damage * dt);
          }

        }
      });
    }

    // --- ç”»é¢æ¸²æŸ“ ---

    draw() {
      this.ctx.fillStyle = BACKGROUND_COLOR;
      this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      const offset = { x: this.camera.x, y: this.camera.y };

      this.drawGrid();

      if (this.state === GameState.GAME || this.state === GameState.LEVEL_UP || this.state === GameState.GAME_OVER) {
        const viewport = this.camera.getViewport();
        const inView = (entity) => entity.x > viewport.left && entity.x < viewport.right && entity.y > viewport.top && entity.y < viewport.bottom;

        this.buildings.filter(inView).forEach(b => b.draw(this.ctx, offset));
        this.projectiles.filter(inView).forEach(p => p.draw(this.ctx, offset));
        this.enemies.filter(inView).forEach(e => e.draw(this.ctx, offset));

        this.player.draw(this.ctx, offset);

        this.drawHUD();
      }

      if (this.state === GameState.MENU) this.drawMenu();
      else if (this.state === GameState.LEVEL_UP) this.drawLevelUpScreen();
      else if (this.state === GameState.GAME_OVER) this.drawGameOverScreen();

      // ç»˜åˆ¶ Wave è½¬æ¢æç¤º
      if (this.isWaveTransition) this.drawWaveTransition();
    }

    drawGrid() {
      this.ctx.strokeStyle = GRID_COLOR;
      this.ctx.lineWidth = 1;
      const step = 50;

      const startX = -this.camera.x % step;
      const startY = -this.camera.y % step;

      for (let x = startX; x < CANVAS_WIDTH; x += step) {
        this.ctx.beginPath();
        this.ctx.moveTo(x, 0);
        this.ctx.lineTo(x, CANVAS_HEIGHT);
        this.ctx.stroke();
      }

      for (let y = startY; y < CANVAS_HEIGHT; y += step) {
        this.ctx.beginPath();
        this.ctx.moveTo(0, y);
        this.ctx.lineTo(CANVAS_WIDTH, y);
        this.ctx.stroke();
      }
    }

    drawText(text, x, y, size, color = 'white', font = 'Arial', align = 'left') {
      this.ctx.font = `${size}px ${font}`;
      this.ctx.fillStyle = color;
      this.ctx.textAlign = align;
      this.ctx.fillText(text, x, y);
    }

    drawWaveTransition() {
      const centerX = CANVAS_WIDTH / 2;
      const centerY = CANVAS_HEIGHT / 2;

      // æ¸å˜é€æ˜çš„èƒŒæ™¯é®ç½©
      const alpha = Math.min(0.8, Math.abs(this.waveTransitionTimer - 1.5) / 1.5);
      this.ctx.fillStyle = `rgba(10, 10, 30, ${alpha})`;
      this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // æ–‡æœ¬é—ªçƒæ•ˆæœ
      const flash = Math.abs(Math.sin(this.currentTime * 5));

      this.drawText(`WAVE ${this.wave}`, centerX, centerY - 50, 120, '#FFD700', 'Impact', 'center');

      if (this.wave >= 2) {
        this.drawText(`ç”Ÿæˆ ${this.wave} ä¸ª Boss! å‡†å¤‡å¥½å¯†é›†æ•Œäººå†²å‡»!`, centerX, centerY + 50, 48, `rgba(255, 50, 50, ${flash})`, 'Arial', 'center');
      } else {
        this.drawText(`æ•Œäººæ­£åœ¨é è¿‘! å¯†é›†æ¥è¢­!`, centerX, centerY + 50, 48, `rgba(0, 255, 0, ${flash})`, 'Arial', 'center');
      }
    }

    drawMenu() {
      const centerX = CANVAS_WIDTH / 2;

      this.drawText("DANTAO", centerX, 200, 90, '#FFD700', 'Impact', 'center');
      this.drawText("æ— å°½ Wave ç”Ÿå­˜æ¨¡å¼", centerX, 270, 40, 'white', 'Arial', 'center');

      const startButton = { x: 550, y: 400, w: 300, h: 60 };
      this.ctx.fillStyle = '#4650a3';
      this.ctx.fillRect(startButton.x, startButton.y, startButton.w, startButton.h);
      this.ctx.strokeStyle = 'white';
      this.ctx.lineWidth = 3;
      this.ctx.strokeRect(startButton.x, startButton.y, startButton.w, startButton.h);
      this.drawText("å¼€å§‹æ¸¸æˆ", centerX, 445, 36, 'white', 'Arial', 'center');

      this.drawText(`æœ€é«˜åˆ†: ${this.data.highScore}`, 100, CANVAS_HEIGHT - 30, 24, 'white');
      this.drawText(`é‡‘å¸: ${this.data.coins}`, centerX, CANVAS_HEIGHT - 30, 24, '#FFD700', 'Arial', 'center');
      this.drawText(`å½“å‰çš®è‚¤: ${this.data.currentSkin.toUpperCase()}`, CANVAS_WIDTH - 100, CANVAS_HEIGHT - 30, 24, 'white', 'Arial', 'right');
    }

    drawHUD() {
      const p = this.player;
      const hudX = 20;
      const hudY = 20;

      // --- HP Bar ---
      const hpBarW = 350;
      const hpBarH = 35;
      const hpRatio = p.health / p.maxHealth;
      let hpColor = hpRatio > 0.6 ? 'rgb(50, 255, 50)' : (hpRatio > 0.3 ? 'rgb(255, 200, 50)' : 'rgb(255, 50, 50)');

      this.ctx.fillStyle = 'rgb(100, 30, 30)';
      this.ctx.fillRect(hudX, hudY, hpBarW, hpBarH);
      this.ctx.fillStyle = hpColor;
      this.ctx.fillRect(hudX, hudY, hpBarW * hpRatio, hpBarH);
      this.ctx.strokeStyle = 'white';
      this.ctx.lineWidth = 3;
      this.ctx.strokeRect(hudX, hudY, hpBarW, hpBarH);
      this.drawText(`HP: ${Math.floor(p.health)}/${p.maxHealth}`, hudX + 10, hudY + 25, 24, 'white');

      // --- EXP Bar ---
      const expBarW = 350;
      const expBarH = 25;
      const expRatio = p.exp / p.expToNextLevel;

      this.ctx.fillStyle = 'rgb(30, 60, 100)';
      this.ctx.fillRect(hudX, hudY + hpBarH + 5, expBarW, expBarH);
      this.ctx.fillStyle = 'rgb(100, 200, 255)';
      this.ctx.fillRect(hudX, hudY + hpBarH + 5, expBarW * expRatio, expBarH);
      this.ctx.strokeStyle = 'white';
      this.ctx.lineWidth = 2;
      this.ctx.strokeRect(hudX, hudY + hpBarH + 5, expBarW, expBarH);
      this.drawText(`Lv.${p.level} - ${p.exp}/${p.expToNextLevel} XP`, hudX + 10, hudY + hpBarH + 22, 20, 'white');

      // --- Wave & Kill Progress ---
      const waveInfoX = CANVAS_WIDTH / 2;
      const activeBosses = this.enemies.filter(e => e instanceof BossEnemy).length;

      this.drawText(`WAVE ${this.wave}`, waveInfoX, hudY + 30, 48, '#FFD700', 'Impact', 'center');

      const killText = `å‡»æ€ç›®æ ‡: ${this.enemiesKilledThisWave}/${this.enemiesToKillForNextWave}`;
      const bossText = `Boss: ${activeBosses} å­˜æ´»`;

      this.drawText(killText, waveInfoX, hudY + 65, 24, 'white', 'Arial', 'center');
      this.drawText(bossText, waveInfoX, hudY + 90, 24, activeBosses > 0 ? 'rgb(255, 50, 50)' : 'rgb(50, 255, 50)', 'Arial', 'center');

      // --- Score ---
      const scoreX = CANVAS_WIDTH - 20;
      this.drawText(`Score: ${Math.floor(p.score)}`, scoreX, hudY + 30, 32, 'white', 'Arial', 'right');

      // --- æŠ€èƒ½æŒ‡ç¤ºå™¨ (Q, C, E) ---
      const skillInfo = [
        { key: 'Q', name: "æŠ¤ç›¾", color: 'rgb(0, 150, 255)', max: p.shieldMaxCooldown, current: p.shieldCooldown, active: p.isShielded },
        { key: 'C', name: "å¢ä¼¤", color: 'rgb(255, 100, 0)', max: p.buffMaxCooldown, current: p.buffCooldown, active: p.isBuffed },
        { key: 'E', name: "å†²å‡»æ³¢", color: 'rgb(100, 200, 255)', max: p.shockwaveMaxCooldown, current: p.shockwaveCooldown, active: p.isShockwaving }
      ];

      const skillBaseX = CANVAS_WIDTH - 250;
      const skillY = CANVAS_HEIGHT - 50;
      const skillSize = 70;
      const skillGap = 100;

      skillInfo.forEach((skill, index) => {
        const skillX = skillBaseX + index * skillGap;

        const skillRatio = Math.max(0, skill.current / skill.max);

        // Background
        this.ctx.fillStyle = 'rgba(50, 50, 50, 0.5)';
        this.ctx.fillRect(skillX - skillSize / 2, skillY - skillSize / 2, skillSize, skillSize);

        // Cooldown overlay
        if (skillRatio > 0) {
          this.ctx.fillStyle = 'rgba(20, 20, 40, 0.7)';
          this.ctx.fillRect(skillX - skillSize / 2, skillY - skillSize / 2, skillSize, skillSize * skillRatio);

          this.drawText(Math.ceil(skill.current).toString(), skillX, skillY + 10, 40, '#FFD700', 'Impact', 'center');
        } else {
          // Ready or Active state text
          const textColor = skill.active ? 'rgb(255, 255, 255)' : skill.color;

          if (skill.active) {
            // Active background glow
            this.ctx.fillStyle = skill.color;
            this.ctx.globalAlpha = Math.sin(this.currentTime * 15) * 0.3 + 0.7;
            this.ctx.fillRect(skillX - skillSize / 2, skillY - skillSize / 2, skillSize, skillSize);
            this.ctx.globalAlpha = 1.0;
          }

          this.drawText(skill.key, skillX, skillY + 10, 40, textColor, 'Impact', 'center');
        }

        // Border
        this.ctx.strokeStyle = skill.current > 0 ? 'rgb(100, 100, 100)' : skill.color;
        this.ctx.lineWidth = 3;
        this.ctx.strokeRect(skillX - skillSize / 2, skillY - skillSize / 2, skillSize, skillSize);

        // Name
        this.drawText(skill.name + ` (${skill.key})`, skillX, skillY + skillSize / 2 + 25, 20, 'white', 'Arial', 'center');
      });
    }

    drawLevelUpScreen() {
      const centerX = CANVAS_WIDTH / 2;
      const centerY = CANVAS_HEIGHT / 2;

      this.ctx.fillStyle = 'rgba(10, 10, 30, 0.95)';
      this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      this.drawText("â˜… å‡ çº§! â˜…", centerX, centerY - 250, 90, '#FFD700', 'Impact', 'center');
      this.drawText(`ç­‰çº§ ${this.player.level}!`, centerX, centerY - 180, 50, 'white', 'Arial', 'center');
      this.drawText("é€‰æ‹©ä¸€ä¸ªå‡çº§:", centerX, centerY - 100, 36, 'white', 'Arial', 'center');

      const options = [
        { key: '1', icon: 'âš”', name: "å¢åŠ ä¼¤å®³", effect: "+25% æ”»å‡»ä¼¤å®³", color: 'rgb(255, 100, 100)' },
        { key: '2', icon: 'â¤', name: "å¢åŠ ç”Ÿå‘½", effect: "+30 æœ€å¤§ç”Ÿå‘½å€¼", color: 'rgb(255, 50, 150)' },
        { key: '3', icon: 'â¤', name: "ç§»åŠ¨é€Ÿåº¦", effect: "+15% ç§»åŠ¨é€Ÿåº¦", color: 'rgb(100, 200, 255)' }
      ];

      let startY = centerY - 30;
      const cardW = 400;
      const cardH = 100;

      options.forEach((opt, index) => {
        const y = startY + index * (cardH + 20);

        this.ctx.fillStyle = opt.color;
        this.ctx.globalAlpha = 0.4;
        this.ctx.fillRect(centerX - cardW / 2, y, cardW, cardH);
        this.ctx.globalAlpha = 1.0;
        this.ctx.strokeStyle = 'white';
        this.ctx.lineWidth = 4;
        this.ctx.strokeRect(centerX - cardW / 2, y, cardW, cardH);

        this.drawText(`[${opt.key}]`, centerX - cardW / 2 + 30, y + 60, 48, '#FFD700', 'Arial', 'left');
        this.drawText(opt.icon, centerX - 50, y + 40, 36, 'white', 'Arial', 'left');
        this.drawText(opt.name, centerX - 50, y + 75, 30, 'white', 'Arial', 'left');
        this.drawText(opt.effect, centerX + 100, y + 60, 24, 'lightgray', 'Arial', 'center');
      });

      this.drawText("æŒ‰ 1, 2, æˆ– 3 é€‰æ‹©å‡çº§", centerX, CANVAS_HEIGHT - 50, 30, 'white', 'Arial', 'center');
    }

    drawGameOverScreen() {
      const centerX = CANVAS_WIDTH / 2;
      const centerY = CANVAS_HEIGHT / 2;

      this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      this.drawText("æ¸¸æˆç»“æŸ", centerX, centerY - 150, 100, 'rgb(255, 50, 50)', 'Impact', 'center');

      this.drawText(`å¾—åˆ†: ${Math.floor(this.player.score)}`, centerX, centerY - 20, 48, 'white', 'Arial', 'center');
      this.drawText(`æœ€é«˜åˆ†: ${this.data.highScore}`, centerX, centerY + 40, 36, '#FFD700', 'Arial', 'center');

      const coinsGained = Math.floor(this.player.score / 2000);
      this.drawText(`æœ¬å±€è¾¾åˆ° Wave ${this.wave}`, centerX, centerY + 100, 40, 'rgb(255, 255, 0)', 'Arial', 'center');
      this.drawText(`è·å¾—é‡‘å¸: +${coinsGained}`, centerX, centerY + 150, 32, 'rgb(0, 200, 0)', 'Arial', 'center');

      this.drawText("æŒ‰ R é‡æ–°å¼€å§‹ | æŒ‰ ESC è¿”å›èœå•", centerX, CANVAS_HEIGHT - 100, 30, 'lightgray', 'Arial', 'center');
    }

    run() {
      const loop = (currentTime) => {
        if (!this.running) return;

        const dt = (currentTime - this.lastTime) / 1000.0 || 0;
        this.lastTime = currentTime;

        this.update(dt);
        this.draw();

        requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);
    }
  }

  window.onload = () => {
    gameInstance = new Game();
  };

</script>
</body>
</html>
